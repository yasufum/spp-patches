From - Tue Jan 22 17:36:45 2019
X-Account-Key: account1
X-UIDL: 00009a2656a584ea
X-Mozilla-Status: 0001
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                 
Return-Path: <x-fn-spp@sl.ntt-tx.co.jp>
X-Original-To: yo128@mail2.ecl.ntt.co.jp
Delivered-To: yo128@mail2.ecl.ntt.co.jp
Received: from dmail1.ecl.ntt.co.jp (dmail1.ecl.ntt.co.jp [129.60.86.151])
	by jcms-pop21.ecl.ntt.co.jp (Postfix) with ESMTP id 88D7B400BC2
	for <yo128@mail2.ecl.ntt.co.jp>; Tue, 22 Jan 2019 17:31:11 +0900 (JST)
Received: by dmail1.ecl.ntt.co.jp (Postfix)
	id 870B823BB50; Tue, 22 Jan 2019 17:31:11 +0900 (JST)
Delivered-To: ogawa.yasufumi@lab.ntt.co.jp
Received: from bcmv-ns01.ecl.ntt.co.jp (bcmv-ns01.ecl.ntt.co.jp [129.60.83.123])
	by dmail1.ecl.ntt.co.jp (Postfix) with ESMTP id 8328023BAF7
	for <ogawa.yasufumi@lab.ntt.co.jp>; Tue, 22 Jan 2019 17:31:11 +0900 (JST)
Received: from bcmv-ns01.ecl.ntt.co.jp (localhost [127.0.0.1])
	by bcmv-ns01.ecl.ntt.co.jp (Postfix) with ESMTP id 7062F12B
	for <ogawa.yasufumi@lab.ntt.co.jp>; Tue, 22 Jan 2019 17:31:11 +0900 (JST)
Received: from dcma-spm02.ecl.ntt.co.jp (unknown [129.60.87.149])
	by bcmv-ns01.ecl.ntt.co.jp (Postfix) with ESMTP id 44554F4
	for <ogawa.yasufumi@lab.ntt.co.jp>; Tue, 22 Jan 2019 17:31:11 +0900 (JST)
Authentication-Results: dcma-spm02.ecl.ntt.co.jp; spf=Pass smtp.pra=x-fn-spp@sl.ntt-tx.co.jp; spf=Pass smtp.mailfrom=x-fn-spp@sl.ntt-tx.co.jp
Received-SPF: Pass (dcma-spm02.ecl.ntt.co.jp: domain of
  x-fn-spp@sl.ntt-tx.co.jp designates 210.232.35.69 as
  permitted sender) identity=pra; client-ip=210.232.35.69;
  receiver=dcma-spm02.ecl.ntt.co.jp;
  envelope-from="x-fn-spp@sl.ntt-tx.co.jp";
  x-sender="x-fn-spp@sl.ntt-tx.co.jp";
  x-conformance=sidf_strict; x-record-type="v=spf1";
  x-record-text="v=spf1 a:mail03.ics.ntt-tx.co.jp
  a:mail04.ics.ntt-tx.co.jp a:mail05.ics.ntt-tx.co.jp
  a:mail06.ics.ntt-tx.co.jp a:mail07.ics.ntt-tx.co.jp
  a:mail08.ics.ntt-tx.co.jp ip4:210.232.35.195
  ip4:210.232.35.196 ip4:210.232.35.65 ip4:210.232.35.66 ~all"
Received-SPF: Pass (dcma-spm02.ecl.ntt.co.jp: domain of
  x-fn-spp@sl.ntt-tx.co.jp designates 210.232.35.69 as
  permitted sender) identity=mailfrom; client-ip=210.232.35.69;
  receiver=dcma-spm02.ecl.ntt.co.jp;
  envelope-from="x-fn-spp@sl.ntt-tx.co.jp";
  x-sender="x-fn-spp@sl.ntt-tx.co.jp";
  x-conformance=sidf_strict; x-record-type="v=spf1";
  x-record-text="v=spf1 a:mail03.ics.ntt-tx.co.jp
  a:mail04.ics.ntt-tx.co.jp a:mail05.ics.ntt-tx.co.jp
  a:mail06.ics.ntt-tx.co.jp a:mail07.ics.ntt-tx.co.jp
  a:mail08.ics.ntt-tx.co.jp ip4:210.232.35.195
  ip4:210.232.35.196 ip4:210.232.35.65 ip4:210.232.35.66 ~all"
IronPort-PHdr: =?us-ascii?q?9a23=3AF2RunBXpk41TecYpThlaop/RHPfV8LGuZFw894?=
 =?us-ascii?q?YnhrRSc6+q45XlOgnl6O5wiEPSBNyEuf5PjuOTqLjlATZG7J2F9nYebNpHUF?=
 =?us-ascii?q?kHkZZehBQuVfaMElazN/v2d2oiBs0XRBpr+TSgKVB9A8K4YUHO52GiqzUVXB?=
 =?us-ascii?q?fnZkJuPuqgIofJlIys0vyqvZjaYgFGnj24NKM3IhPzth3JntISx41+NuMt2l?=
 =?us-ascii?q?3CpT1KY70Ml1llLl+SgRvwo/yI0sA7rHZosuk6v45MWqDzOr8gSOQCSjktNy?=
 =?us-ascii?q?Yz+NGtvh6FTxPdrncbV2wXlFJPDW2npFnqG5n39zDirsJm3G+cIdGzUaByUj?=
 =?us-ascii?q?Pk7b8jRBLziSgBPiI06ymN05Q21vkB5kn84UIui4fPBePdfOJzZKbcYc8XSS?=
 =?us-ascii?q?JaU8BdWjYASoKwYo0TDvYQaP5Cptq1rF8PoB2iQAi0Ubm2knkS3SWwhvB8jb?=
 =?us-ascii?q?VydGOOlBYtFN8PrnnO+dn+Ma5XSviwlPOOwD7HKfVKxXH2787KakNEw7nEUL?=
 =?us-ascii?q?RufM7W0URqGRnCiwDaucnrOXaOzvwlqGzd6fZ8EP6/zWUg7QNp6GvKpI9kms?=
 =?us-ascii?q?zSi4QZx0qRvzU8zoBwPsWgYFV/J9i4DN5Mp2eRMM10WolxJgMg8DZ/wboAt5?=
 =?us-ascii?q?mheSEMw5ly3B/TZcucb5KJ6Q6wHPbUOzpzg2hpPa6unxvnu1b10fXyD4PntT?=
 =?us-ascii?q?QC5joAiNTHsWoBkgDe+tTSAOUo5V+vgH6GhQXa6+UcegY1nrGdLYI9h6Ig0J?=
 =?us-ascii?q?EU90bbe02+0EykiaaXch14vOmj8KLhfqmjuo/aPIgyiBm2O/Yrk827Wbl+Mw?=
 =?us-ascii?q?MVGW6H5aGgxPvo+gv7WNAoxrU/wKzQsZSCe4IarbX/BRNJl5ozrR24STW+mN?=
 =?us-ascii?q?1KmHAGKAoaPhOMlM7vJ02LPOC+BvD5gUzJ8n8jzqLDN7zlWsWLL3PY1rH9Yf?=
 =?us-ascii?q?Nh+whXz0wx1Zhe/84GUOhZZqioAAmq6ZqBX0JcUUT8wv67Wo8kjsVEAjjJWf?=
 =?us-ascii?q?LfafKM+V6QurB1erHKPtRP/m2gbaZ4r//20S1jwAdbJ/Lzm8BKLi7mVuJvJ0?=
 =?us-ascii?q?HTOCC+uNoKHGYUswZ7d9TE1gTYAwZafG36H6434zh+E5qjVd2FS4upxrqdwG?=
 =?us-ascii?q?GwGdtUfjIOBleJGHbuP4KKPpVEIDLXLMkkiSQcfaOlDYk9yVSypEnxzPxlNq?=
 =?us-ascii?q?LY9zYZupTqyNVur7eKzVdormYyVJnbjTDFRnoR/CtAXzIs2aFjvUFxgkyO16?=
 =?us-ascii?q?R1mb0QFNBe4e9IThZvMJfdy+JgDNWhEgnFf9qPVBOnWoD8WGl3FIlrhYRTJR?=
 =?us-ascii?q?gsSLDAxljZ0iGnAqEYjemHD5k9t7nE2iCrYct2zzDAyLVnhF5gQNMcUA/uzq?=
 =?us-ascii?q?N56QXXAJbE1kuDkKP/P7RZ0iiI73+b5XGK+kdETEtsQePOWjYdfgGFyLaxrl?=
 =?us-ascii?q?OHVLKoBbk9Z0FRjMCEb7BScvXyiRNAWOumJMSYaGX3mX/6VnPqjvucKYHtfW?=
 =?us-ascii?q?saxiDUDkMJxhsS8XixLhQkByy98CrOSSZjHlX1bwbw4PFz/TmlG1QswVjAPC?=
 =?us-ascii?q?gDn/KlvwQYjvuGR7YP06IY7W0//i5sEg/11oDTAtuE/1Enfa5HJ9Uh/BJbxS?=
 =?us-ascii?q?TSsEp/JvnCZ+hr1FsXcgAv4wXv3A4xDJlc1NQ66ngtighqYavK1VpAc2vFm5?=
 =?us-ascii?q?H7IfvRNnW34ADpYKmQ2Em7sp7e8/UK4fU88wulvQqyUEw+7zB7w59e1D2e/t?=
 =?us-ascii?q?3DXg8bUJapDQA2/AM8oa3GJzUtoYjTk390VMv8+jaQ3tsoALN1jBerZJFZLL?=
 =?us-ascii?q?/BCB+0GMpcBdDmKfR2yQLwNlReZ7oUr/NyZpL7EpnOkK+zYLQ6xWrg1z8dpt?=
 =?us-ascii?q?sglBvdqWJ9UrKahc9dhavDhE3cCnGi0R+gqpylw9kcI2tJRCzklG66WsZHb6?=
 =?us-ascii?q?l2N99aW1frGNW+w5BFv7CoXndZ8FC5AFZfh52yfVyUc0C4wR0W3kNRo2T1wH?=
 =?us-ascii?q?LknQwxqCkgq++k5AKL2/7rLUVVIWoNQnV+yEv8Z4OzydICDhGl?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ADAABr00Zch0Uj6NJkGgEBAQEBAgE?=
 =?us-ascii?q?BAQEHAgEBAQGBUwMBAQEBCwGCAIFZAwcIJ4x6jRWYARSBZ4R5AjWCUgEFMQc?=
 =?us-ascii?q?NAQMBAQIBAQEBFAEBAQgNCQgpL4VLAwMnUhAgDCUPSAcSgyKCAa0vM4h6gSy?=
 =?us-ascii?q?IAFWBKIRagRGHWBWGBgKHEzcHggqGLxNuV5A+CYp7gyqDdhiSFC2JV5JmCIF?=
 =?us-ascii?q?/gUCCbII1jjYwAQEBMAGIUAEkB4IgAQE?=
X-SPF-Status: pass
Received: from mail05.ics.ntt-tx.co.jp (HELO mail04.ics.ntt-tx.co.jp) ([210.232.35.69])
  by dcma-spm02.ecl.ntt.co.jp with ESMTP; 22 Jan 2019 17:31:10 +0900
Received: from gwchk03.silk.ntt-tx.co.jp (gwchk03.silk.ntt-tx.co.jp [10.107.0.111])
	by mail04.ics.ntt-tx.co.jp (unknown) with ESMTP id x0M8Ux9g013758;
	Tue, 22 Jan 2019 17:30:59 +0900
Received: (from root@localhost)
	by gwchk03.silk.ntt-tx.co.jp (unknown) id x0M8Ux89014657;
	Tue, 22 Jan 2019 17:30:59 +0900
Received: from gwchk.silk.ntt-tx.co.jp [10.107.0.110] 
	 by gwchk03.silk.ntt-tx.co.jp with ESMTP id SAA07436;
	 Tue, 22 Jan 2019 16:19:21 +0900
Received: from imss04.silk.ntt-tx.co.jp (localhost [127.0.0.1]) by imss04.silk.ntt-tx.co.jp (unknown) with ESMTP id x0M7JLaq015674; Tue, 22 Jan 2019 16:19:21 +0900
Received: from mgate01.silk.ntt-tx.co.jp (smtp02.silk.ntt-tx.co.jp [10.107.0.37]) by imss04.silk.ntt-tx.co.jp (unknown) with ESMTP id x0M7JKtV015671; Tue, 22 Jan 2019 16:19:20 +0900
Message-Id: <201901220719.x0M7JKtV015671@imss04.silk.ntt-tx.co.jp>
Received: from localhost by mgate01.silk.ntt-tx.co.jp (unknown)
	id x0M7JKpL009185 ; Tue, 22 Jan 2019 16:19:20 +0900
From: x-fn-spp@sl.ntt-tx.co.jp
To: ferruh.yigit@intel.com, ogawa.yasufumi@lab.ntt.co.jp
Cc: spp@dpdk.org
Subject: [PATCH 2/7] spp_pcap: add command decode
Date: Tue, 22 Jan 2019 16:19:15 +0900
X-Mailer: git-send-email 2.18.0
In-Reply-To: <20190122071920.2464-1-x-fn-spp@sl.ntt-tx.co.jp>
References: <20190122071920.2464-1-x-fn-spp@sl.ntt-tx.co.jp>
X-TM-AS-MML: disable

From: Hideyuki Yamashita <yamashita.hideyuki@po.ntt-tx.co.jp>

Add command decode part for start, stop and status.

Signed-off-by: Hideyuki Yamashita <yamashita.hideyuki@po.ntt-tx.co.jp>
Signed-off-by: Naoki Takada <takada.naoki@lab.ntt.co.jp>
---
 src/pcap/command_dec.c | 187 +++++++++++++++++++++++++++++++++++++++++
 src/pcap/command_dec.h | 110 ++++++++++++++++++++++++
 2 files changed, 297 insertions(+)
 create mode 100644 src/pcap/command_dec.c
 create mode 100644 src/pcap/command_dec.h

diff --git a/src/pcap/command_dec.c b/src/pcap/command_dec.c
new file mode 100644
index 0000000..943ab0f
--- /dev/null
+++ b/src/pcap/command_dec.c
@@ -0,0 +1,187 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019 Nippon Telegraph and Telephone Corporation
+ */
+
+#include <unistd.h>
+#include <string.h>
+
+#include <rte_ether.h>
+#include <rte_log.h>
+#include <rte_branch_prediction.h>
+
+#include "command_dec.h"
+
+#define RTE_LOGTYPE_SPP_COMMAND_DEC RTE_LOGTYPE_USER2
+
+/* set parse error */
+static inline int
+set_parse_error(struct spp_command_parse_error *error,
+		const int error_code, const char *error_name)
+{
+	error->code = error_code;
+
+	if (likely(error_name != NULL))
+		strcpy(error->value_name, error_name);
+
+	return error->code;
+}
+
+/* set parse error */
+static inline int
+set_string_value_parse_error(struct spp_command_parse_error *error,
+		const char *value, const char *error_name)
+{
+	strcpy(error->value, value);
+	return set_parse_error(error, BAD_VALUE, error_name);
+}
+
+/* Split command line parameter with spaces */
+static int
+parse_parameter_value(char *string, int max, int *argc, char *argv[])
+{
+	int cnt = 0;
+	const char *delim = " ";
+	char *argv_tok = NULL;
+	char *saveptr = NULL;
+
+	argv_tok = strtok_r(string, delim, &saveptr);
+	while (argv_tok != NULL) {
+		if (cnt >= max)
+			return SPP_RET_NG;
+		argv[cnt] = argv_tok;
+		cnt++;
+		argv_tok = strtok_r(NULL, delim, &saveptr);
+	}
+	*argc = cnt;
+
+	return SPP_RET_OK;
+}
+
+/* command list for parse */
+struct parse_command_list {
+	const char *name;       /* Command name */
+	int   param_min;        /* Min number of parameters */
+	int   param_max;        /* Max number of parameters */
+	int (*func)(struct spp_command_request *request, int argc,
+			char *argv[], struct spp_command_parse_error *error,
+			int maxargc);
+				/* Pointer to command handling function */
+	enum spp_command_type type;
+				/* Command type */
+};
+
+/* command list */
+static struct parse_command_list command_list_pcap[] = {
+	{ "_get_client_id", 1, 1, NULL, CMD_CLIENT_ID },
+	{ "status",	    1, 1, NULL, CMD_STATUS    },
+	{ "exit",           1, 1, NULL, CMD_EXIT      },
+	{ "start",          1, 1, NULL, CMD_START     },
+	{ "stop",           1, 1, NULL, CMD_STOP      },
+	{ "",               0, 0, NULL, 0 }  /* termination */
+};
+
+/* Parse command line parameters */
+static int
+parse_command_in_list(struct spp_command_request *request,
+			const char *request_str,
+			struct spp_command_parse_error *error)
+{
+	int ret = SPP_RET_OK;
+	int command_name_check = 0;
+	struct parse_command_list *list = NULL;
+	int i = 0;
+	int argc = 0;
+	char *argv[SPP_CMD_MAX_PARAMETERS];
+	char tmp_str[SPP_CMD_MAX_PARAMETERS*SPP_CMD_VALUE_BUFSZ];
+	memset(argv, 0x00, sizeof(argv));
+	memset(tmp_str, 0x00, sizeof(tmp_str));
+
+	strcpy(tmp_str, request_str);
+	ret = parse_parameter_value(tmp_str, SPP_CMD_MAX_PARAMETERS,
+			&argc, argv);
+	if (ret < SPP_RET_OK) {
+		RTE_LOG(ERR, SPP_COMMAND_DEC, "Parameter number over limit."
+				"request_str=%s\n", request_str);
+		return set_parse_error(error, BAD_FORMAT, NULL);
+	}
+	RTE_LOG(DEBUG, SPP_COMMAND_DEC, "Decode array. num=%d\n", argc);
+
+	for (i = 0; command_list_pcap[i].name[0] != '\0'; i++) {
+		list = &command_list_pcap[i];
+		if (strcmp(argv[0], list->name) != 0)
+			continue;
+
+		if (unlikely(argc < list->param_min) ||
+				unlikely(list->param_max < argc)) {
+			command_name_check = 1;
+			continue;
+		}
+
+		request->commands[0].type = command_list_pcap[i].type;
+		if (list->func != NULL)
+			return (*list->func)(request, argc, argv, error,
+							list->param_max);
+
+		return SPP_RET_OK;
+	}
+
+	if (command_name_check != 0) {
+		RTE_LOG(ERR, SPP_COMMAND_DEC, "Parameter number out of range."
+				"request_str=%s\n", request_str);
+		return set_parse_error(error, BAD_FORMAT, NULL);
+	}
+
+	RTE_LOG(ERR, SPP_COMMAND_DEC,
+			"Unknown command. command=%s, request_str=%s\n",
+			argv[0], request_str);
+	return set_string_value_parse_error(error, argv[0], "command");
+}
+
+/* parse request from no-null-terminated string */
+int
+spp_command_parse_request(
+		struct spp_command_request *request,
+		const char *request_str, size_t request_str_len,
+		struct spp_command_parse_error *error)
+{
+	int ret = SPP_RET_NG;
+	int i;
+
+	/* parse request */
+	request->num_command = 1;
+	ret = parse_command_in_list(request, request_str, error);
+	if (unlikely(ret != SPP_RET_OK)) {
+		RTE_LOG(ERR, SPP_COMMAND_DEC,
+				"Cannot parse command request. "
+				"ret=%d, request_str=%.*s\n",
+				ret, (int)request_str_len, request_str);
+		return ret;
+	}
+	request->num_valid_command = 1;
+
+	/* check getter command */
+	for (i = 0; i < request->num_valid_command; ++i) {
+		switch (request->commands[i].type) {
+		case CMD_CLIENT_ID:
+			request->is_requested_client_id = 1;
+			break;
+		case CMD_STATUS:
+			request->is_requested_status = 1;
+			break;
+		case CMD_EXIT:
+			request->is_requested_exit = 1;
+			break;
+		case CMD_START:
+			request->is_requested_start = 1;
+			break;
+		case CMD_STOP:
+			request->is_requested_stop = 1;
+			break;
+		default:
+			/* nothing to do */
+			break;
+		}
+	}
+
+	return ret;
+}
diff --git a/src/pcap/command_dec.h b/src/pcap/command_dec.h
new file mode 100644
index 0000000..0835382
--- /dev/null
+++ b/src/pcap/command_dec.h
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2019 Nippon Telegraph and Telephone Corporation
+ */
+
+#ifndef _SPP_PCAP_COMMAND_DEC_H_
+#define _SPP_PCAP_COMMAND_DEC_H_
+
+/**
+ * @file
+ * SPP pcap command parse
+ *
+ * Decode and validate the command message string.
+ */
+
+#include "spp_proc.h"
+
+/** max number of command per request */
+#define SPP_CMD_MAX_COMMANDS 32
+
+/** maximum number of parameters per command */
+#define SPP_CMD_MAX_PARAMETERS 8
+
+/** command name string buffer size (include null char) */
+#define SPP_CMD_NAME_BUFSZ  32
+
+/** command value string buffer size (include null char) */
+#define SPP_CMD_VALUE_BUFSZ 111
+
+/** parse error code */
+enum spp_command_parse_error_code {
+	/* not use 0, in general 0 is OK */
+	BAD_FORMAT = 1,  /**< Wrong format */
+	UNKNOWN_COMMAND, /**< Unknown command */
+	NO_PARAM,        /**< No parameters */
+	BAD_TYPE,        /**< Wrong data type */
+	BAD_VALUE,       /**< Wrong value */
+};
+
+/**
+ * spp command type.
+ *
+ * @attention This enumerated type must have the same order of command_list
+ *            defined in command_dec_pcap.c
+ */
+enum spp_command_type {
+	/** get_client_id command */
+	CMD_CLIENT_ID,
+
+	/** status command */
+	CMD_STATUS,
+
+	/** exit command */
+	CMD_EXIT,
+
+	/** start command */
+	CMD_START,
+
+	/** stop command */
+	CMD_STOP,
+
+};
+
+/** command parameters */
+struct spp_command {
+	enum spp_command_type type; /**< Command type */
+};
+
+/** request parameters */
+struct spp_command_request {
+	int num_command;                /**< Number of accepted commands */
+	int num_valid_command;          /**< Number of executed commands */
+	struct spp_command commands[SPP_CMD_MAX_COMMANDS];
+					/**<Information of executed commands */
+
+	int is_requested_client_id;     /**< Id for get_client_id command */
+	int is_requested_status;        /**< Id for status command */
+	int is_requested_exit;          /**< Id for exit command */
+	int is_requested_start;         /**< Id for start command */
+	int is_requested_stop;          /**< Id for stop command */
+};
+
+/** parse error information */
+struct spp_command_parse_error {
+	int code;                            /**< Error code */
+	char value_name[SPP_CMD_NAME_BUFSZ]; /**< Error value name */
+	char value[SPP_CMD_VALUE_BUFSZ];     /**< Error value */
+};
+
+/**
+ * parse request from no-null-terminated string
+ *
+ * @param request
+ *  The pointer to struct spp_command_request.@n
+ *  The result value of decoding the command message.
+ * @param request_str
+ *  The pointer to requested command message.
+ * @param request_str_len
+ *  The length of requested command message.
+ * @param error
+ *  The pointer to struct spp_command_parse_error.@n
+ *  Detailed error information will be stored.
+ *
+ * @retval SPP_RET_OK succeeded.
+ * @retval !0 failed.
+ */
+int spp_command_parse_request(struct spp_command_request *request,
+		const char *request_str, size_t request_str_len,
+		struct spp_command_parse_error *error);
+
+#endif /* _COMMAND_DEC_H_ */
-- 
2.17.1



