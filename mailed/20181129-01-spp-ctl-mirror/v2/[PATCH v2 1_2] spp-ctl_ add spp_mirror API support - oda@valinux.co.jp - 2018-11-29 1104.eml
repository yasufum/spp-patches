X-Account-Key: account4
X-UIDL: 000089fa56a584ea
X-Mozilla-Status: 0001
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                 
Return-Path: <oda@valinux.co.jp>
X-Original-To: yo128@mail2.ecl.ntt.co.jp
Delivered-To: yo128@mail2.ecl.ntt.co.jp
Received: from dmail2.ecl.ntt.co.jp (dmail2.ecl.ntt.co.jp [129.60.86.152])
	by jcms-pop21.ecl.ntt.co.jp (Postfix) with ESMTP id E06ED40059D
	for <yo128@mail2.ecl.ntt.co.jp>; Thu, 29 Nov 2018 11:04:15 +0900 (JST)
Received: by dmail2.ecl.ntt.co.jp (Postfix)
	id DE6497F32D; Thu, 29 Nov 2018 11:04:15 +0900 (JST)
Delivered-To: ogawa.yasufumi@lab.ntt.co.jp
Received: from vc1.ecl.ntt.co.jp (vc1.ecl.ntt.co.jp [129.60.86.153])
	by dmail2.ecl.ntt.co.jp (Postfix) with ESMTP id DD3977F07B
	for <ogawa.yasufumi@lab.ntt.co.jp>; Thu, 29 Nov 2018 11:04:15 +0900 (JST)
Received: from vc1.ecl.ntt.co.jp (localhost [127.0.0.1])
	by vc1.ecl.ntt.co.jp (Postfix) with ESMTP id CF6A5EA77F4
	for <ogawa.yasufumi@lab.ntt.co.jp>; Thu, 29 Nov 2018 11:04:15 +0900 (JST)
Received: from dcma-spm01.ecl.ntt.co.jp (unknown [129.60.87.149])
	by vc1.ecl.ntt.co.jp (Postfix) with ESMTP id C4321EA78D5
	for <ogawa.yasufumi@lab.ntt.co.jp>; Thu, 29 Nov 2018 11:04:15 +0900 (JST)
Authentication-Results: dcma-spm01.ecl.ntt.co.jp; spf=None smtp.pra=oda@valinux.co.jp; spf=None smtp.mailfrom=oda@valinux.co.jp
Received-SPF: None (dcma-spm01.ecl.ntt.co.jp: no sender
  authenticity information available from domain of
  oda@valinux.co.jp) identity=pra; client-ip=210.128.90.14;
  receiver=dcma-spm01.ecl.ntt.co.jp;
  envelope-from="oda@valinux.co.jp";
  x-sender="oda@valinux.co.jp"; x-conformance=sidf_strict
Received-SPF: None (dcma-spm01.ecl.ntt.co.jp: no sender
  authenticity information available from domain of
  oda@valinux.co.jp) identity=mailfrom;
  client-ip=210.128.90.14; receiver=dcma-spm01.ecl.ntt.co.jp;
  envelope-from="oda@valinux.co.jp";
  x-sender="oda@valinux.co.jp"; x-conformance=sidf_strict
IronPort-PHdr: =?us-ascii?q?9a23=3AB+TVmBZt84fZSnfJlMZ0dMv/LSx94efdIxIV55?=
 =?us-ascii?q?w7irlHbqWk+dHYMVfC4el21QeSD4nQ7vsBkPLT6/mmVGcEp5CdrDYJd9pOT0?=
 =?us-ascii?q?xNkt0YyionBsPNEkjnNLjydSVvG8hLfEFs+3C9LFgTE8G4ZUWB6maq42s0HR?=
 =?us-ascii?q?PyfRFwOvyzH4fTi8qt0OXn/JHaSxtBgDu7fKM0JxLwrx2I7JssjIBvK7g8xl?=
 =?us-ascii?q?7ymlUSKrwE42RuKBrTkx3574Kr5Js7qmJdsPZn8dJcF679OaYgH/ReC3w9Pm?=
 =?us-ascii?q?Y56deO11GLRBaT5nYaTmQdkwZZSwnD4hbgW57tsyz8/uNj0SieNMfyQPg6Qz?=
 =?us-ascii?q?Onp6tsTRbpjm8AOVtbuCnQhsVYkqtfoRS8t1p0xMjWeMDdNfZzeL/cYcJPXX?=
 =?us-ascii?q?BIDY5aUy1MBJ/5bpNaVbNZe78C/8+s/x1X8UjbZ0HkHu7kxz5Wi2Wj0aY/2q?=
 =?us-ascii?q?E6CQSehUotFNZItmjI6t7ycqUKAoXXhOHFyyvOa/RO1HLz8o/NJ1omrfikQ7?=
 =?us-ascii?q?t0cMzM2Q8kEEXHlh/DzO6tdyPQzekLv2WBuqBnWeuHlWcjqgdssn6kwYEuks?=
 =?us-ascii?q?OazpJQwVfC+yJjxY8zLtDtU093b+m/DIFRvD3DbdlMT8gvQn9ltGMB8pNc6M?=
 =?us-ascii?q?PpWi8MxdxnyxXaYrmca43Qu1TuX+LXJytkwnliPrCn1V609gC7x+vwW9PRsh?=
 =?us-ascii?q?4CpzdZktTKqnEG1gDCosmBRPxn+0692DGJnwnN4+BAKEowmOLVMZkkirI3k5?=
 =?us-ascii?q?MStwzEEEqU0A3xgKa+aEwg++61+6LsZfPkvt7UNoN5jB3/LrV7n8W+BeoiNQ?=
 =?us-ascii?q?1dOgrTse+41bDl4Qj4WOAQ16Vwy/OJ9sGCY51H9eajDgRY05gu8UOzBDKvlc?=
 =?us-ascii?q?8AmCFeal9OfFSBk5SvMFaIIuiraJX3y1mqjjpvwOjLe7P7BZCYZH/PmZ//dL?=
 =?us-ascii?q?J87VNMjgE0i9JHrcExaPlJMLfoV0n9ucaNRBg1OiSqyuLmDshtkIgZH2CXSP?=
 =?us-ascii?q?zRIObZtlmG4fgqKu+HadoOuTrzHOM5/f/lkSZoy29YRrGg2N4sUF79G/1nJ0?=
 =?us-ascii?q?uDZn+134UfGGMLuBcuCuftzl+aA2YKOySCGpkk7zR+M7qISJ/ZT9nw0qKI2C?=
 =?us-ascii?q?a9A40QbWcACEjeSXo=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0A4AACuSP9b/w5agNJkHAEBAQQBAQc?=
 =?us-ascii?q?EAQGBUgYBAQsBggBpcAMECyeMcI01l0KBeigQAYRAAoNMBjEIDQEDAQECAQE?=
 =?us-ascii?q?BAW0ohT0GgQkgMSwrBxKDIQGCAKgOiQCBLIdrRYEigluBf45/AocbB4IHhXt?=
 =?us-ascii?q?2kAEJhn2KKSORFSyISpEZATaBVYQsCZBhMzCBAwEBAQGKMSuCIAEB?=
X-SPF-Status: none
Received: from vagw.valinux.co.jp (HELO valinux.co.jp) ([210.128.90.14])
  by dcma-spm01.ecl.ntt.co.jp with ESMTP; 29 Nov 2018 11:04:15 +0900
Received: by valinux.co.jp (Postfix, from userid 1000)
	id 1E625240A51; Thu, 29 Nov 2018 11:04:13 +0900 (JST)
From: oda@valinux.co.jp
To: spp@dpdk.org,
	ferruh.yigit@intel.com,
	ogawa.yasufumi@lab.ntt.co.jp
Subject: [PATCH v2 1/2] spp-ctl: add spp_mirror API support
Date: Thu, 29 Nov 2018 11:04:12 +0900
Message-Id: <20181129020413.20023-2-oda@valinux.co.jp>
X-Mailer: git-send-email 2.17.1
In-Reply-To: <20181129020413.20023-1-oda@valinux.co.jp>
References: <20181129005512.18526-1-oda@valinux.co.jp>
 <20181129020413.20023-1-oda@valinux.co.jp>
X-TM-AS-MML: disable

From: Itsuro Oda <oda@valinux.co.jp>

This patch adds spp_mirror APIs to spp-ctl.

Signed-off-by: Itsuro Oda <oda@valinux.co.jp>
---
 src/spp-ctl/spp_ctl.py    |   2 +-
 src/spp-ctl/spp_proc.py   |  57 +++++++++++++-----
 src/spp-ctl/spp_webapi.py | 120 ++++++++++++++++++++++++++------------
 3 files changed, 127 insertions(+), 52 deletions(-)

diff --git a/src/spp-ctl/spp_ctl.py b/src/spp-ctl/spp_ctl.py
index 0576ae1..279c180 100644
--- a/src/spp-ctl/spp_ctl.py
+++ b/src/spp-ctl/spp_ctl.py
@@ -128,7 +128,7 @@ class Controller(object):
         # it is a bit ad hoc. send "_get_clinet_id" command and try to
         # decode reply for each proc type. if success, that is the type.
         data = self._send_command(conn, "_get_client_id")
-        for proc in [spp_proc.VfProc, spp_proc.NfvProc]:
+        for proc in [spp_proc.VfProc, spp_proc.NfvProc, spp_proc.MirrorProc]:
             sec_id = proc._decode_client_id(data)
             if sec_id is not None:
                 return proc(sec_id, conn)
diff --git a/src/spp-ctl/spp_proc.py b/src/spp-ctl/spp_proc.py
index 83c59ea..648e085 100644
--- a/src/spp-ctl/spp_proc.py
+++ b/src/spp-ctl/spp_proc.py
@@ -15,6 +15,7 @@ ID_PRIMARY = 0
 TYPE_PRIMARY = "primary"
 TYPE_VF = "vf"
 TYPE_NFV = "nfv"
+TYPE_MIRROR = "mirror"
 
 
 def exec_command(func):
@@ -53,10 +54,10 @@ class SppProc(object):
         self.conn = conn
 
 
-class VfProc(SppProc):
+class VfCommon(SppProc):
 
-    def __init__(self, id, conn):
-        super(VfProc, self).__init__(TYPE_VF, id, conn)
+    def __init__(self, proc_type, id, conn):
+        super(VfCommon, self).__init__(proc_type, id, conn)
 
     @staticmethod
     def _decode_reply(data):
@@ -67,14 +68,6 @@ class VfProc(SppProc):
             raise bottle.HTTPError(400, "command error: %s" % msg)
         return data
 
-    @staticmethod
-    def _decode_client_id(data):
-        try:
-            data = VfProc._decode_reply(data)
-            return data["client_id"]
-        except:
-            return None
-
     @exec_command
     def get_status(self):
         return "status"
@@ -88,6 +81,25 @@ class VfProc(SppProc):
     def stop_component(self, comp_name):
         return "component stop {comp_name}".format(**locals())
 
+    @exec_command
+    def port_del(self, port, direction, comp_name):
+        return "port del {port} {direction} {comp_name}".format(**locals())
+
+
+class VfProc(VfCommon):
+
+    def __init__(self, id, conn):
+        super(VfProc, self).__init__(TYPE_VF, id, conn)
+
+    @staticmethod
+    def _decode_client_id(data):
+        try:
+            data = VfCommon._decode_reply(data)
+            if data["process_type"] == TYPE_VF:
+                return data["client_id"]
+        except:
+            return None
+
     @exec_command
     def port_add(self, port, direction, comp_name, op, vlan_id, pcp):
         command = "port add {port} {direction} {comp_name}".format(**locals())
@@ -97,10 +109,6 @@ class VfProc(SppProc):
                 command += " %d %d" % (vlan_id, pcp)
         return command
 
-    @exec_command
-    def port_del(self, port, direction, comp_name):
-        return "port del {port} {direction} {comp_name}".format(**locals())
-
     @exec_command
     def set_classifier_table(self, mac_address, port):
         return ("classifier_table add mac {mac_address} {port}"
@@ -124,6 +132,25 @@ class VfProc(SppProc):
                 .format(**locals()))
 
 
+class MirrorProc(VfCommon):
+
+    def __init__(self, id, conn):
+        super(MirrorProc, self).__init__(TYPE_MIRROR, id, conn)
+
+    @staticmethod
+    def _decode_client_id(data):
+        try:
+            data = VfCommon._decode_reply(data)
+            if data["process_type"] == TYPE_MIRROR:
+                return data["client_id"]
+        except:
+            return None
+
+    @exec_command
+    def port_add(self, port, direction, comp_name):
+        return "port add {port} {direction} {comp_name}".format(**locals())
+
+
 class NfvProc(SppProc):
 
     def __init__(self, id, conn):
diff --git a/src/spp-ctl/spp_webapi.py b/src/spp-ctl/spp_webapi.py
index 48cc1c4..7547f0e 100644
--- a/src/spp-ctl/spp_webapi.py
+++ b/src/spp-ctl/spp_webapi.py
@@ -114,6 +114,7 @@ class WebServer(BaseHandler):
     /          WebServer
     /v1          V1Handler
        /vfs        V1VFHandler
+       /mirrors    V1MirrorHandler
        /nfvs       V1NFVHandler
        /primary    V1PrimaryHandler
     """
@@ -141,6 +142,7 @@ class V1Handler(BaseHandler):
         self.set_route()
 
         self.mount("/vfs", V1VFHandler(controller))
+        self.mount("/mirrors", V1MirrorHandler(controller))
         self.mount("/nfvs", V1NFVHandler(controller))
         self.mount("/primary", V1PrimaryHandler(controller))
 
@@ -154,7 +156,46 @@ class V1Handler(BaseHandler):
         return self.ctrl.get_processes()
 
 
-class V1VFHandler(BaseHandler):
+class V1VFCommon(object):
+    """Define common methods for vf and mirror handler."""
+
+    def convert_info(self, data):
+        info = data["info"]
+        vf = {}
+        vf["client-id"] = info["client-id"]
+        vf["ports"] = []
+        for key in ["phy", "vhost", "ring"]:
+            for idx in info[key]:
+                vf["ports"].append(key + ":" + str(idx))
+        vf["components"] = info["core"]
+        if "classifier_table" in info:
+            vf["classifier_table"] = info["classifier_table"]
+
+        return vf
+
+    def validate_comp_start(self, body, types):
+        for key in ['name', 'core', 'type']:
+            if key not in body:
+                raise KeyRequired(key)
+        if not isinstance(body['name'], str):
+            raise KeyInvalid('name', body['name'])
+        if not isinstance(body['core'], int):
+            raise KeyInvalid('core', body['core'])
+        if body['type'] not in types:
+            raise KeyInvalid('type', body['type'])
+
+    def validate_comp_port(self, body):
+        for key in ['action', 'port', 'dir']:
+            if key not in body:
+                raise KeyRequired(key)
+        if body['action'] not in ["attach", "detach"]:
+            raise KeyInvalid('action', body['action'])
+        if body['dir'] not in ["rx", "tx"]:
+            raise KeyInvalid('dir', body['dir'])
+        self._validate_port(body['port'])
+
+
+class V1VFHandler(BaseHandler, V1VFCommon):
 
     def __init__(self, controller):
         super(V1VFHandler, self).__init__(controller)
@@ -177,50 +218,18 @@ class V1VFHandler(BaseHandler):
         self.route('/<sec_id:int>/classifier_table', 'PUT',
                    callback=self.vf_classifier)
 
-    def convert_vf_info(self, data):
-        info = data["info"]
-        vf = {}
-        vf["client-id"] = info["client-id"]
-        vf["ports"] = []
-        for key in ["phy", "vhost", "ring"]:
-            for idx in info[key]:
-                vf["ports"].append(key + ":" + str(idx))
-        vf["components"] = info["core"]
-        vf["classifier_table"] = info["classifier_table"]
-
-        return vf
-
     def vf_get(self, proc):
-        return self.convert_vf_info(proc.get_status())
-
-    def _validate_vf_comp_start(self, body):
-        for key in ['name', 'core', 'type']:
-            if key not in body:
-                raise KeyRequired(key)
-        if not isinstance(body['name'], str):
-            raise KeyInvalid('name', body['name'])
-        if not isinstance(body['core'], int):
-            raise KeyInvalid('core', body['core'])
-        if body['type'] not in ["forward", "merge", "classifier_mac"]:
-            raise KeyInvalid('type', body['type'])
+        return self.convert_info(proc.get_status())
 
     def vf_comp_start(self, proc, body):
-        self._validate_vf_comp_start(body)
+        self.validate_comp_start(body, ["forward", "merge", "classifier_mac"])
         proc.start_component(body['name'], body['core'], body['type'])
 
     def vf_comp_stop(self, proc, name):
         proc.stop_component(name)
 
     def _validate_vf_comp_port(self, body):
-        for key in ['action', 'port', 'dir']:
-            if key not in body:
-                raise KeyRequired(key)
-        if body['action'] not in ["attach", "detach"]:
-            raise KeyInvalid('action', body['action'])
-        if body['dir'] not in ["rx", "tx"]:
-            raise KeyInvalid('dir', body['dir'])
-        self._validate_port(body['port'])
-
+        self.validate_comp_port(body)
         if body['action'] == "attach":
             vlan = body.get('vlan')
             if vlan:
@@ -296,6 +305,45 @@ class V1VFHandler(BaseHandler):
                     mac_address, port, body['vlan'])
 
 
+class V1MirrorHandler(BaseHandler, V1VFCommon):
+
+    def __init__(self, controller):
+        super(V1MirrorHandler, self).__init__(controller)
+        self.type = spp_proc.TYPE_MIRROR
+
+        self.set_route()
+
+        self.install(self.check_sec_id)
+        self.install(self.get_body)
+        self.install(self.make_response)
+
+    def set_route(self):
+        self.route('/<sec_id:int>', 'GET', callback=self.mirror_get)
+        self.route('/<sec_id:int>/components', 'POST',
+                   callback=self.mirror_comp_start)
+        self.route('/<sec_id:int>/components/<name>', 'DELETE',
+                   callback=self.mirror_comp_stop)
+        self.route('/<sec_id:int>/components/<name>/ports', 'PUT',
+                   callback=self.mirror_comp_port)
+
+    def mirror_get(self, proc):
+        return self.convert_info(proc.get_status())
+
+    def mirror_comp_start(self, proc, body):
+        self.validate_comp_start(body, ["mirror"])
+        proc.start_component(body['name'], body['core'], body['type'])
+
+    def mirror_comp_stop(self, proc, name):
+        proc.stop_component(name)
+
+    def mirror_comp_port(self, proc, name, body):
+        self.validate_comp_port(body)
+        if body['action'] == "attach":
+            proc.port_add(body['port'], body['dir'], name)
+        else:
+            proc.port_del(body['port'], body['dir'], name)
+
+
 class V1NFVHandler(BaseHandler):
 
     def __init__(self, controller):
-- 
2.17.1


