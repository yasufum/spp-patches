From e234f45b4c44e96391150af75639aff015775282 Mon Sep 17 00:00:00 2001
From: Yasufumi Ogawa <ogawa.yasufumi@lab.ntt.co.jp>
Date: Mon, 31 Dec 2018 14:36:22 +0900
Subject: [PATCH 1/2] spp_vm: remove spp_vm

This update is to remove spp_vm from SPP.

Spp_vm is used to connect between apps in the VM, but it is almost the
same as launching spp_primary and spp_nfv on the VM. In addition,
IVSHMEM is not supported in DPDK anymore.

Signed-off-by: Yasufumi Ogawa <ogawa.yasufumi@lab.ntt.co.jp>
---
 src/Makefile    |   1 -
 src/vm/Makefile |  38 ----
 src/vm/args.c   |  79 -------
 src/vm/args.h   |  16 --
 src/vm/init.c   | 113 ----------
 src/vm/init.h   |  15 --
 src/vm/main.c   | 669 --------------------------------------------------------
 7 files changed, 931 deletions(-)
 delete mode 100644 src/vm/Makefile
 delete mode 100644 src/vm/args.c
 delete mode 100644 src/vm/args.h
 delete mode 100644 src/vm/init.c
 delete mode 100644 src/vm/init.h
 delete mode 100644 src/vm/main.c

diff --git a/src/Makefile b/src/Makefile
index 01f8929..8e2bffa 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -40,7 +40,6 @@ include $(RTE_SDK)/mk/rte.vars.mk
 
 DIRS-$(CONFIG_RTE_EXEC_ENV_LINUXAPP) += nfv
 DIRS-$(CONFIG_RTE_EXEC_ENV_LINUXAPP) += primary
-DIRS-$(CONFIG_RTE_EXEC_ENV_LINUXAPP) += vm
 DIRS-$(CONFIG_RTE_EXEC_ENV_LINUXAPP) += vf
 DIRS-$(CONFIG_RTE_EXEC_ENV_LINUXAPP) += mirror
 
diff --git a/src/vm/Makefile b/src/vm/Makefile
deleted file mode 100644
index be3fa5e..0000000
--- a/src/vm/Makefile
+++ /dev/null
@@ -1,38 +0,0 @@
-# SPDX-License-Identifier: BSD-3-Clause
-# Copyright(c) 2015-2016 Intel Corporation
-
-ifeq ($(RTE_SDK),)
-$(error "Please define RTE_SDK environment variable")
-endif
-
-# Default target, can be overriden by command line or environment
-RTE_TARGET ?= x86_64-native-linuxapp-gcc
-
-include $(RTE_SDK)/mk/rte.vars.mk
-
-ifneq ($(CONFIG_RTE_EXEC_ENV),"linuxapp")
-$(error This application can only operate in a linuxapp environment, \
-please change the definition of the RTE_TARGET environment variable)
-endif
-
-# binary name
-APP = spp_vm
-
-# all source are stored in SRCS-y
-SRCS-y := main.c init.c args.c ../shared/common.c
-
-INC := $(wildcard *.h)
-
-CFLAGS += -DALLOW_EXPERIMENTAL_API
-CFLAGS += $(WERROR_FLAGS) -O3 -MMD
-CFLAGS += -I$(SRCDIR)/../shared
-
-ifeq ($(CONFIG_RTE_BUILD_SHARED_LIB),y)
-LDLIBS += -lrte_pmd_ring
-endif
-
-# for newer gcc, e.g. 4.4, no-strict-aliasing may not be necessary
-# and so the next line can be removed in those cases.
-EXTRA_CFLAGS += -fno-strict-aliasing
-
-include $(RTE_SDK)/mk/rte.extapp.mk
diff --git a/src/vm/args.c b/src/vm/args.c
deleted file mode 100644
index 4ae0e33..0000000
--- a/src/vm/args.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright(c) 2015-2016 Intel Corporation
- */
-
-#include <getopt.h>
-
-#include <rte_memory.h>
-
-#include "args.h"
-#include "common.h"
-#include "init.h"
-
-/* global var for number of clients - extern in header */
-uint16_t client_id;
-char *server_ip;
-int server_port;
-
-static const char *progname;
-
-/**
- * Prints out usage information to stdout
- */
-static void
-usage(void)
-{
-	RTE_LOG(INFO, APP,
-	    "%s [EAL options] -- -p PORTMASK -n CLIENT_ID [-s NUM_SOCKETS]\n"
-	    " -p PORTMASK: hexadecimal bitmask of ports to use\n"
-	    " -n CLIENT_ID: the requested if of current client\n"
-	    , progname);
-}
-
-/**
- * The application specific arguments follow the DPDK-specific
- * arguments which are stripped by the DPDK init. This function
- * processes these application arguments, printing usage info
- * on error.
- */
-int
-parse_app_args(uint16_t max_ports, int argc, char *argv[])
-{
-	int option_index, opt;
-	char **argvopt = argv;
-	static struct option lgopts[] = { {0} };
-	int ret;
-
-	progname = argv[0];
-
-	while ((opt = getopt_long(argc, argvopt, "n:p:s:", lgopts,
-			&option_index)) != EOF) {
-		switch (opt) {
-		case 'p':
-			if (parse_portmask(ports, max_ports, optarg) != 0) {
-				usage();
-				return -1;
-			}
-			break;
-		case 'n':
-			if (parse_num_clients(&client_id, optarg) != 0) {
-				usage();
-				return -1;
-			}
-			break;
-		case 's':
-			ret = parse_server(&server_ip, &server_port, optarg);
-			if (ret != 0) {
-				usage();
-				return -1;
-			}
-			break;
-		default:
-			RTE_LOG(ERR, APP, "Unknown option '%c'\n", opt);
-			usage();
-			return -1;
-		}
-	}
-
-	return 0;
-}
diff --git a/src/vm/args.h b/src/vm/args.h
deleted file mode 100644
index d675ba5..0000000
--- a/src/vm/args.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright(c) 2015-2016 Intel Corporation
- */
-
-#ifndef _ARGS_H_
-#define _ARGS_H_
-
-#include <stdint.h>
-
-extern uint16_t client_id;
-extern char *server_ip;
-extern int server_port;
-
-int parse_app_args(uint16_t max_ports, int argc, char *argv[]);
-
-#endif /* ifndef _ARGS_H_ */
diff --git a/src/vm/init.c b/src/vm/init.c
deleted file mode 100644
index dd4353d..0000000
--- a/src/vm/init.c
+++ /dev/null
@@ -1,113 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright(c) 2015-2016 Intel Corporation
- */
-
-#include <limits.h>
-
-#include <rte_cycles.h>
-#include <rte_memory.h>
-#include <rte_memzone.h>
-
-#include "args.h"
-#include "common.h"
-#include "init.h"
-
-/* The mbuf pool for packet rx */
-static struct rte_mempool *pktmbuf_pool;
-
-/* the port details */
-struct port_info *ports;
-
-/**
- * Initialise the mbuf pool for packet reception for the NIC, and any other
- * buffer pools needed by the app - currently none.
- */
-static int
-init_mbuf_pools(int total_ports)
-{
-	const unsigned int num_mbufs = total_ports * MBUFS_PER_PORT;
-
-	if (num_mbufs == 0)
-		return 0;
-
-	/*
-	 * don't pass single-producer/single-consumer flags to mbuf create as
-	 * it seems faster to use a cache instead
-	 */
-	RTE_LOG(INFO, APP,
-		"Lookup mbuf pool '%s' [%u mbufs] ...\n", VM_PKTMBUF_POOL_NAME,
-		num_mbufs);
-
-	pktmbuf_pool = rte_mempool_lookup(VM_PKTMBUF_POOL_NAME);
-	if (pktmbuf_pool == NULL) {
-		RTE_LOG(INFO, APP, "Creating mbuf pool '%s' [%u mbufs] ...\n",
-			VM_PKTMBUF_POOL_NAME, num_mbufs);
-
-		pktmbuf_pool = rte_mempool_create(VM_PKTMBUF_POOL_NAME,
-			num_mbufs, MBUF_SIZE, MBUF_CACHE_SIZE,
-			sizeof(struct rte_pktmbuf_pool_private),
-			rte_pktmbuf_pool_init, NULL, rte_pktmbuf_init, NULL,
-			rte_socket_id(), NO_FLAGS);
-	}
-
-	return (pktmbuf_pool == NULL); /* 0  on success */
-}
-
-/**
- * Main init function for the multi-process server app,
- * calls subfunctions to do each stage of the initialisation.
- */
-int
-init(int argc, char *argv[])
-{
-	int retval;
-	const struct rte_memzone *mz;
-	uint16_t count, total_ports;
-
-	/* init EAL, parsing EAL args */
-	retval = rte_eal_init(argc, argv);
-	if (retval < 0)
-		return -1;
-
-	argc -= retval;
-	argv += retval;
-
-	/* get total number of ports */
-	total_ports = rte_eth_dev_count_avail();
-
-	/* set up array for port data */
-	mz = rte_memzone_lookup(MZ_PORT_INFO);
-	if (mz == NULL) {
-		RTE_LOG(DEBUG, APP, "Cannot get port info structure\n");
-		mz = rte_memzone_reserve(MZ_PORT_INFO, sizeof(*ports),
-			rte_socket_id(), NO_FLAGS);
-		if (mz == NULL)
-			rte_exit(EXIT_FAILURE,
-				"Cannot reserve memzone for port info\n");
-		memset(mz->addr, 0, sizeof(*ports));
-	}
-	ports = mz->addr;
-
-	/* parse additional, application arguments */
-	retval = parse_app_args(total_ports, argc, argv);
-	if (retval != 0)
-		return -1;
-
-	/* initialise mbuf pools */
-	retval = init_mbuf_pools(total_ports);
-	if (retval != 0)
-		rte_exit(EXIT_FAILURE, "Cannot create needed mbuf pools\n");
-
-	/* now initialise the ports we will use */
-	if (rte_eal_process_type() == RTE_PROC_PRIMARY) {
-		for (count = 0; count < total_ports; count++) {
-			retval = init_port(ports->id[count], pktmbuf_pool);
-			if (retval != 0)
-				rte_exit(EXIT_FAILURE,
-					"Cannot initialise port %d\n", count);
-		}
-	}
-	check_all_ports_link_status(ports, total_ports, (~0x0));
-
-	return 0;
-}
diff --git a/src/vm/init.h b/src/vm/init.h
deleted file mode 100644
index 6837873..0000000
--- a/src/vm/init.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright(c) 2015-2016 Intel Corporation
- */
-
-#ifndef _INIT_H_
-#define _INIT_H_
-
-#include <stdint.h>
-
-/* the shared port information: port numbers, rx and tx stats etc. */
-extern struct port_info *ports;
-
-int init(int argc, char *argv[]);
-
-#endif /* ifndef _INIT_H_ */
diff --git a/src/vm/main.c b/src/vm/main.c
deleted file mode 100644
index c41502a..0000000
--- a/src/vm/main.c
+++ /dev/null
@@ -1,669 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause
- * Copyright(c) 2015-2016 Intel Corporation
- */
-
-#include <arpa/inet.h>
-
-#include <rte_eal_memconfig.h>
-#include <rte_eth_ring.h>
-#include <rte_memzone.h>
-
-#include "args.h"
-#include "common.h"
-#include "init.h"
-
-static sig_atomic_t on = 1;
-
-static enum cmd_type cmd = STOP;
-
-static struct port_map port_map[RTE_MAX_ETHPORTS];
-
-static struct port ports_fwd_array[RTE_MAX_ETHPORTS];
-
-/* It is used to convert port name from string type to enum */
-struct porttype_map {
-	const char     *port_name;
-	enum port_type port_type;
-};
-
-struct porttype_map portmap[] = {
-	{ .port_name = "phy",   .port_type = PHY, },
-	{ .port_name = "ring",  .port_type = RING, },
-	{ .port_name = "vhost", .port_type = VHOST, },
-	{ .port_name = NULL,    .port_type = UNDEF, },
-};
-
-/* Return a type of port as a enum member of porttype_map structure. */
-static enum port_type get_port_type(char *portname)
-{
-	for (int i = 0; portmap[i].port_name != NULL; i++) {
-		const char *port_name = portmap[i].port_name;
-		if (strncmp(portname, port_name, strlen(port_name)) == 0)
-			return portmap[i].port_type;
-	}
-	return UNDEF;
-}
-
-static void
-forward(void)
-{
-	uint16_t nb_rx;
-	uint16_t nb_tx;
-	uint16_t buf;
-	int in_port;
-	int out_port;
-	int i;
-
-	/* Go through every possible port numbers */
-	for (i = 0; i < RTE_MAX_ETHPORTS; i++) {
-		struct rte_mbuf *bufs[MAX_PKT_BURST];
-
-		if (ports_fwd_array[i].in_port_id == PORT_RESET)
-			continue;
-
-		if (ports_fwd_array[i].out_port_id == PORT_RESET)
-			continue;
-
-		/* if status active, i count is in port */
-		in_port = i;
-		out_port = ports_fwd_array[i].out_port_id;
-
-		/* Get burst of RX packets, from first port of pair. */
-		/* first port rx, second port tx */
-		nb_rx = ports_fwd_array[in_port].rx_func(in_port, 0, bufs,
-			MAX_PKT_BURST);
-		if (unlikely(nb_rx == 0))
-			continue;
-
-		port_map[in_port].stats->rx += nb_rx;
-
-		/* Send burst of TX packets, to second port of pair. */
-		nb_tx = ports_fwd_array[out_port].tx_func(out_port, 0, bufs,
-			nb_rx);
-
-		port_map[out_port].stats->tx += nb_tx;
-
-		/* Free any unsent packets. */
-		if (unlikely(nb_tx < nb_rx)) {
-			port_map[out_port].stats->tx_drop += nb_rx - nb_tx;
-			for (buf = nb_tx; buf < nb_rx; buf++)
-				rte_pktmbuf_free(bufs[buf]);
-		}
-	}
-}
-
-/* main processing loop */
-static void
-nfv_loop(void)
-{
-	unsigned int lcore_id = rte_lcore_id();
-
-	RTE_LOG(INFO, APP, "entering main loop on lcore %u\n", lcore_id);
-
-	while (1) {
-		if (unlikely(cmd == STOP)) {
-			sleep(1);
-			continue;
-		} else if (cmd == FORWARD) {
-			forward();
-		}
-	}
-}
-
-/* leading to nfv processing loop */
-static int
-main_loop(void *dummy __rte_unused)
-{
-	nfv_loop();
-	return 0;
-}
-
-static void
-port_map_init_one(unsigned int i)
-{
-	port_map[i].id = PORT_RESET;
-	port_map[i].port_type = UNDEF;
-	port_map[i].stats = &port_map[i].default_stats;
-}
-
-static void
-port_map_init(void)
-{
-	unsigned int i;
-
-	for (i = 0; i < RTE_MAX_ETHPORTS; i++)
-		port_map_init_one(i);
-}
-
-static void
-forward_array_init_one(int i)
-{
-	ports_fwd_array[i].in_port_id = PORT_RESET;
-	ports_fwd_array[i].out_port_id = PORT_RESET;
-}
-
-/* initialize forward array with default value */
-static void
-forward_array_init(void)
-{
-	unsigned int i;
-
-	/* initialize port forward array */
-	for (i = 0; i < RTE_MAX_ETHPORTS; i++)
-		forward_array_init_one(i);
-}
-
-static int
-do_send(int *connected, int *sock, char *str)
-{
-	int ret;
-
-	ret = send(*sock, str, MSG_SIZE, 0);
-	if (ret == -1) {
-		RTE_LOG(ERR, APP, "send failed");
-		*connected = 0;
-		return -1;
-	}
-
-	RTE_LOG(INFO, APP, "To Server: %s\n", str);
-
-	return 0;
-}
-
-static void
-forward_array_reset(void)
-{
-	unsigned int i;
-
-	/* initialize port forward array */
-	for (i = 0; i < RTE_MAX_ETHPORTS; i++) {
-		if (ports_fwd_array[i].in_port_id != PORT_RESET) {
-			ports_fwd_array[i].out_port_id = PORT_RESET;
-			RTE_LOG(INFO, APP, "Port ID %d\n", i);
-			RTE_LOG(INFO, APP, "out_port_id %d\n",
-				ports_fwd_array[i].out_port_id);
-		}
-	}
-}
-
-static void
-forward_array_remove(int port_id)
-{
-	unsigned int i;
-
-	/* Update ports_fwd_array */
-	forward_array_init_one(port_id);
-
-	for (i = 0; i < RTE_MAX_ETHPORTS; i++) {
-		if (ports_fwd_array[i].in_port_id == PORT_RESET)
-			continue;
-
-		if (ports_fwd_array[i].out_port_id == port_id) {
-			ports_fwd_array[i].out_port_id = PORT_RESET;
-			break;
-		}
-	}
-}
-
-/*
- * Return actual port ID which is assigned by system internally, or PORT_RESET
- * if port is not found.
- */
-static uint16_t
-find_port_id(int id, enum port_type type)
-{
-	uint16_t port_id = PORT_RESET;
-	uint16_t i;
-
-	for (i = 0; i < RTE_MAX_ETHPORTS; i++) {
-		if (port_map[i].port_type != type)
-			continue;
-
-		if (port_map[i].id == id) {
-			port_id = i;
-			break;
-		}
-	}
-
-	return port_id;
-}
-
-static int
-do_del(char *res_uid)
-{
-	uint16_t port_id = PORT_RESET;
-	char *p_type;
-	int p_id;
-	int res;
-
-	res = parse_resource_uid(res_uid, &p_type, &p_id);
-	if (res < 0) {
-		RTE_LOG(ERR, APP,
-			"Failed to parse resource UID\n");
-		return -1;
-	}
-
-	if (!strcmp(p_type, "ring")) {
-		RTE_LOG(DEBUG, APP, "Del ring id %d\n", p_id);
-		port_id = find_port_id(p_id, RING);
-		if (port_id == PORT_RESET)
-			return -1;
-
-		dev_detach_by_port_id(port_id);
-	}
-
-	forward_array_remove(port_id);
-	port_map_init_one(port_id);
-
-	return 0;
-}
-
-/* Return 0 if invalid */
-static int
-is_valid_port(uint16_t port_id)
-{
-	if (port_id > RTE_MAX_ETHPORTS)
-		return 0;
-
-	return port_map[port_id].id != PORT_RESET;
-}
-
-/* Return -1 as an error if given patch is invalid */
-static int
-add_patch(uint16_t in_port, uint16_t out_port)
-{
-	if (!is_valid_port(in_port) || !is_valid_port(out_port))
-		return -1;
-
-	/* Populate in port data */
-	ports_fwd_array[in_port].in_port_id = in_port;
-	ports_fwd_array[in_port].rx_func = &rte_eth_rx_burst;
-	ports_fwd_array[in_port].tx_func = &rte_eth_tx_burst;
-	ports_fwd_array[in_port].out_port_id = out_port;
-
-	/* Populate out port data */
-	ports_fwd_array[out_port].in_port_id = out_port;
-	ports_fwd_array[out_port].rx_func = &rte_eth_rx_burst;
-	ports_fwd_array[out_port].tx_func = &rte_eth_tx_burst;
-
-	RTE_LOG(DEBUG, APP, "STATUS: in port %d in_port_id %d\n", in_port,
-		ports_fwd_array[in_port].in_port_id);
-	RTE_LOG(DEBUG, APP, "STATUS: in port %d patch out port id %d\n",
-		in_port, ports_fwd_array[in_port].out_port_id);
-	RTE_LOG(DEBUG, APP, "STATUS: outport %d in_port_id %d\n", out_port,
-		ports_fwd_array[out_port].in_port_id);
-
-	return 0;
-}
-
-static struct rte_memzone *
-get_memzone_by_addr(const void *addr)
-{
-	struct rte_memzone *tmp, *mz;
-	struct rte_mem_config *mcfg;
-	struct rte_fbarray *arr;
-	int i;
-
-	mcfg = rte_eal_get_configuration()->mem_config;
-	arr = &mcfg->memzones;
-	mz = NULL;
-
-	/* find memzone for the ring */
-	i = rte_fbarray_find_next_used(arr, 0);
-	while (i >= 0) {
-		tmp = rte_fbarray_get(arr, i);
-		if (mz->addr_64 == (uint64_t) addr) {
-			mz = tmp;
-			break;
-		}
-		i = rte_fbarray_find_next_used(arr, i+1);
-	}
-
-	return mz;
-}
-
-/*
- * Create ring PMD with given ring_id.
- */
-static int
-add_ring_pmd(int ring_id)
-{
-	const struct rte_memzone *memzone;
-	struct rte_ring *ring;
-	int res;
-	char rx_queue_name[32];  /* Prefix and number like as 'eth_ring_0' */
-
-	memset(rx_queue_name, '\0', sizeof(rx_queue_name));
-	sprintf(rx_queue_name, "%s", get_rx_queue_name(ring_id));
-
-	/* Look up ring with provided ring_id */
-	ring = rte_ring_lookup(rx_queue_name);
-	if (ring == NULL) {
-		RTE_LOG(ERR, APP,
-			"Failed to get RX ring %s - is primary running?\n",
-			rx_queue_name);
-		return -1;
-	}
-	RTE_LOG(INFO, APP, "Looked up ring '%s'\n", rx_queue_name);
-
-	memzone = get_memzone_by_addr(ring);
-	if (memzone == NULL) {
-		RTE_LOG(ERR, APP, "Cannot get memzone\n");
-		return -1;
-	}
-
-	/* Create ring pmd */
-	ring->memzone = memzone;
-	res = rte_eth_from_ring(ring);
-	if (res < 0) {
-		RTE_LOG(ERR, APP,
-			"Cannot create eth dev with rte_eth_from_ring()\n");
-		return -1;
-	}
-	RTE_LOG(INFO, APP, "Created ring PMD: %d\n", res);
-
-	return res;
-}
-
-/**
- * Add a port to this process. Port is described with resource UID which is a
- * combination of port type and ID like as 'ring:0'.
- */
-static int
-do_add(char *res_uid)
-{
-	enum port_type type = UNDEF;
-	uint16_t port_id = PORT_RESET;
-	char *p_type;
-	int p_id;
-	int res;
-
-	res = parse_resource_uid(res_uid, &p_type, &p_id);
-	if (res < 0)
-		return -1;
-
-	if (!strcmp(p_type, "ring")) {
-		type = RING;
-		res = add_ring_pmd(p_id);
-	}
-
-	if (res < 0)
-		return -1;
-	else
-		port_id = (uint16_t) res;
-
-	port_map[port_id].id = p_id;
-	port_map[port_id].port_type = type;
-	port_map[port_id].stats = &ports->client_stats[p_id];
-
-	/* Update ports_fwd_array with port id */
-	ports_fwd_array[port_id].in_port_id = port_id;
-
-	return 0;
-}
-
-/* Return -1 if exit command is called to terminate the process */
-static int
-parse_command(char *str)
-{
-	char *token_list[MAX_PARAMETER] = {NULL};
-	int max_token = 0;
-	int ret = 0;
-
-	if (!str)
-		return 0;
-
-	/* tokenize the user commands from controller */
-	token_list[max_token] = strtok(str, " ");
-	while (token_list[max_token] != NULL) {
-		RTE_LOG(DEBUG, APP, "token %d = %s\n", max_token,
-			token_list[max_token]);
-		max_token++;
-		token_list[max_token] = strtok(NULL, " ");
-	}
-
-	if (max_token == 0)
-		return 0;
-
-	if (!strcmp(token_list[0], "status")) {
-		RTE_LOG(DEBUG, APP, "status\n");
-		memset(str, '\0', MSG_SIZE);
-		if (cmd == FORWARD)
-			get_sec_stats_json(str, client_id, "running",
-					ports_fwd_array, port_map);
-		else
-			get_sec_stats_json(str, client_id, "idling",
-					ports_fwd_array, port_map);
-
-	} else if (!strcmp(token_list[0], "_get_client_id")) {
-		memset(str, '\0', MSG_SIZE);
-		sprintf(str, "%d", client_id);
-
-	} else if (!strcmp(token_list[0], "_set_client_id")) {
-		int id;
-
-		if (spp_atoi(token_list[1], &id) >= 0)
-			client_id = id;
-
-	} else if (!strcmp(token_list[0], "exit")) {
-		RTE_LOG(DEBUG, APP, "exit\n");
-		RTE_LOG(DEBUG, APP, "stop\n");
-		cmd = STOP;
-		ret = -1;
-
-	} else if (!strcmp(token_list[0], "stop")) {
-		RTE_LOG(DEBUG, APP, "stop\n");
-		cmd = STOP;
-
-	} else if (!strcmp(token_list[0], "forward")) {
-		RTE_LOG(DEBUG, APP, "forward\n");
-		cmd = FORWARD;
-
-	} else if (strncmp(token_list[0], "add", 3) == 0) {
-		RTE_LOG(DEBUG, APP, "Received add command\n");
-		if (do_add(token_list[1]) < 0)
-			RTE_LOG(ERR, APP, "Failed to do_add()\n");
-
-	} else if (!strcmp(token_list[0], "patch")) {
-		RTE_LOG(DEBUG, APP, "patch\n");
-
-		if (max_token <= 1)
-			return 0;
-
-		if (strncmp(token_list[1], "reset", 5) == 0) {
-			/* reset forward array*/
-			forward_array_reset();
-		} else {
-			uint16_t in_port;
-			uint16_t out_port;
-
-			if (max_token <= 2)
-				return 0;
-
-			char *in_p_type;
-			char *out_p_type;
-			int in_p_id;
-			int out_p_id;
-
-			parse_resource_uid(token_list[1], &in_p_type, &in_p_id);
-			in_port = find_port_id(in_p_id,
-					get_port_type(in_p_type));
-
-			parse_resource_uid(token_list[2],
-					&out_p_type, &out_p_id);
-			out_port = find_port_id(out_p_id,
-					get_port_type(out_p_type));
-
-			if (in_port == PORT_RESET && out_port == PORT_RESET) {
-				char err_msg[128];
-				memset(err_msg, '\0', sizeof(err_msg));
-				sprintf(err_msg, "%s '%s:%d' and '%s:%d'",
-						"Patch not found, both of",
-						in_p_type, in_p_id,
-						out_p_type, out_p_id);
-				RTE_LOG(ERR, APP, "%s\n", err_msg);
-			} else if (in_port == PORT_RESET) {
-				char err_msg[128];
-				memset(err_msg, '\0', sizeof(err_msg));
-				sprintf(err_msg, "%s '%s:%d'",
-						"Patch not found, in_port",
-						in_p_type, in_p_id);
-				RTE_LOG(ERR, APP, "%s\n", err_msg);
-			} else if (out_port == PORT_RESET) {
-				char err_msg[128];
-				memset(err_msg, '\0', sizeof(err_msg));
-				sprintf(err_msg, "%s '%s:%d'",
-						"Patch not found, out_port",
-						out_p_type, out_p_id);
-				RTE_LOG(ERR, APP, "%s\n", err_msg);
-			}
-
-			if (add_patch(in_port, out_port) == 0)
-				RTE_LOG(INFO, APP,
-					"Patched '%s:%d' and '%s:%d'\n",
-					in_p_type, in_p_id,
-					out_p_type, out_p_id);
-			else
-				RTE_LOG(ERR, APP, "Failed to patch\n");
-			ret = 0;
-		}
-	} else if (strncmp(str, "del", 3) == 0) {
-		RTE_LOG(DEBUG, APP, "Received del command\n");
-
-		cmd = STOP;
-
-		if (do_del(token_list[1]) < 0)
-			RTE_LOG(ERR, APP, "Failed to do_del()\n");
-	}
-
-	return ret;
-}
-
-static int
-do_receive(int *connected, int *sock, char *str)
-{
-	int ret;
-
-	memset(str, '\0', MSG_SIZE);
-
-	ret = recv(*sock, str, MSG_SIZE, 0);
-	if (ret <= 0) {
-		RTE_LOG(DEBUG, APP, "Receive count: %d\n", ret);
-		if (ret < 0)
-			RTE_LOG(ERR, APP, "Receive Fail");
-		else
-			RTE_LOG(INFO, APP, "Receive 0\n");
-
-		RTE_LOG(INFO, APP, "Assume Server closed connection\n");
-		close(*sock);
-		*sock = SOCK_RESET;
-		*connected = 0;
-		return -1;
-	}
-
-	return 0;
-}
-
-static int
-do_connection(int *connected, int *sock)
-{
-	static struct sockaddr_in servaddr;
-	int ret = 0;
-
-	if (*connected == 0) {
-		if (*sock < 0) {
-			RTE_LOG(INFO, APP, "Creating socket...\n");
-			*sock = socket(AF_INET, SOCK_STREAM, 0);
-			if (*sock < 0)
-				rte_exit(EXIT_FAILURE, "socket error\n");
-
-			/* Creation of the socket */
-			memset(&servaddr, 0, sizeof(servaddr));
-			servaddr.sin_family = AF_INET;
-			servaddr.sin_addr.s_addr = inet_addr(server_ip);
-			servaddr.sin_port = htons(server_port);
-		}
-
-		RTE_LOG(INFO, APP, "Trying to connect ... socket %d\n", *sock);
-		ret = connect(*sock, (struct sockaddr *) &servaddr,
-			sizeof(servaddr));
-		if (ret < 0) {
-			RTE_LOG(ERR, APP, "Connection Error");
-			return ret;
-		}
-
-		RTE_LOG(INFO, APP, "Connected\n");
-		*connected = 1;
-	}
-
-	return ret;
-}
-
-int
-main(int argc, char *argv[])
-{
-	unsigned int lcore_id;
-	int sock = SOCK_RESET;
-	int connected = 0;
-	char str[MSG_SIZE];
-	int ret;
-	int flg_exit;  // used as res of parse_command() to exit if -1
-	int i;
-
-	/* initialise the system */
-	if (init(argc, argv) < 0)
-		return -1;
-
-	/* initialize port forward array*/
-	forward_array_init();
-	port_map_init();
-
-	/* update port_forward_array with active port */
-	for (i = 0; i < RTE_MAX_ETHPORTS; i++) {
-		if (!rte_eth_dev_is_valid_port(i))
-			continue;
-
-		/* Update ports_fwd_array with phy port*/
-		ports_fwd_array[i].in_port_id = i;
-		port_map[i].port_type = PHY;
-		port_map[i].id = i;
-		port_map[i].stats = &ports->port_stats[i];
-	}
-
-	RTE_LOG(INFO, APP, "Finished Process Init.\n");
-
-	lcore_id = 0;
-	RTE_LCORE_FOREACH_SLAVE(lcore_id) {
-		rte_eal_remote_launch(main_loop, NULL, lcore_id);
-	}
-
-	while (on) {
-		ret = do_connection(&connected, &sock);
-		if (ret < 0) {
-			sleep(1);
-			continue;
-		}
-
-		ret = do_receive(&connected, &sock, str);
-		if (ret < 0)
-			continue;
-
-		RTE_LOG(DEBUG, APP, "Received string: %s\n", str);
-
-		flg_exit = parse_command(str);
-
-		/* Send the message back to client */
-		ret = do_send(&connected, &sock, str);
-
-		if (flg_exit < 0)  /* terminate process if exit is called */
-			break;
-		else if (ret < 0)
-			continue;
-	}
-
-	/* exit */
-	close(sock);
-	sock = SOCK_RESET;
-	RTE_LOG(INFO, APP, "spp_vm exit.\n");
-	return 0;
-}
-- 
2.7.4

