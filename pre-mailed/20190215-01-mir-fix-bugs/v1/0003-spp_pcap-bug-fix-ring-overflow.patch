From 8a1ed5712f999ea7c6bb9f77ce4011c803c4568f Mon Sep 17 00:00:00 2001
From: Hideyuki Yamashita <yamashita.hideyuki@po.ntt-tx.co.jp>
Date: Tue, 5 Feb 2019 11:16:52 +0900
Subject: [PATCH 3/3] spp_pcap: bug fix ring overflow

To prevent ring overflow in start which it starts and confirms of the
write thread.

Signed-off-by: Hideyuki Yamashita <yamashita.hideyuki@po.ntt-tx.co.jp>
Signed-off-by: Naoki Takada <takada.naoki@lab.ntt.co.jp>
---
 src/pcap/spp_pcap.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/src/pcap/spp_pcap.c b/src/pcap/spp_pcap.c
index 1b67d9c..cd984fa 100644
--- a/src/pcap/spp_pcap.c
+++ b/src/pcap/spp_pcap.c
@@ -138,6 +138,12 @@ struct pcap_mng_info {
 	uint64_t file_size;            /* file write size */
 };
 
+/* Pcap status info. */
+struct pcap_status_info {
+	int thread_cnt;		/* thread count */
+	int start_up_cnt;	/* thread start up count */
+};
+
 /* Logical core ID for main thread */
 static unsigned int g_main_lcore_id = 0xffffffff;
 
@@ -162,6 +168,9 @@ static struct pcap_option g_pcap_option;
 /* pcap managed info */
 static struct pcap_mng_info g_pcap_info[RTE_MAX_LCORE];
 
+/* pcap thread status info */
+struct pcap_status_info g_pcap_thread_info;
+
 /* Print help message */
 static void
 usage(const char *progname)
@@ -772,6 +781,8 @@ static int pcap_proc_receive(int lcore_id)
 								lcore_id);
 			info->status = SPP_CAPTURE_IDLE;
 			g_capture_status = SPP_CAPTURE_IDLE;
+			if (g_pcap_thread_info.start_up_cnt != 0)
+				g_pcap_thread_info.start_up_cnt -= 1;
 		}
 		return SPP_RET_OK;
 	}
@@ -787,8 +798,13 @@ static int pcap_proc_receive(int lcore_id)
 		RTE_LOG(DEBUG, SPP_PCAP, "recive[%d], idle->run\n", lcore_id);
 		RTE_LOG(DEBUG, SPP_PCAP, "recive[%d], start time=%s\n",
 			lcore_id, g_pcap_option.compress_file_date);
+		g_pcap_thread_info.start_up_cnt += 1;
 	}
 
+	/* Write thread start up wait. */
+	if (g_pcap_thread_info.thread_cnt > g_pcap_thread_info.start_up_cnt)
+		return SPP_RET_OK;
+
 	/* Receive packets */
 	rx = &g_pcap_option.port_cap;
 
@@ -833,6 +849,7 @@ static int pcap_proc_write(int lcore_id)
 			info->status = SPP_CAPTURE_IDLE;
 			return SPP_RET_NG;
 		}
+		g_pcap_thread_info.start_up_cnt += 1;
 	}
 
 	/* Read packets */
@@ -843,6 +860,8 @@ static int pcap_proc_write(int lcore_id)
 			RTE_LOG(DEBUG, SPP_PCAP, "write[%d] run->idle\n",
 								lcore_id);
 			info->status = SPP_CAPTURE_IDLE;
+			if (g_pcap_thread_info.start_up_cnt != 0)
+				g_pcap_thread_info.start_up_cnt -= 1;
 			if (file_compression_operation(info, CLOSE_MODE)
 							!= SPP_RET_OK)
 				return SPP_RET_NG;
@@ -1038,7 +1057,10 @@ main(int argc, char *argv[])
 		/* Start worker threads of recive or write */
 		unsigned int lcore_id = 0;
 		unsigned int thread_no = 0;
+		g_pcap_thread_info.thread_cnt = 0;
+		g_pcap_thread_info.start_up_cnt = 0;
 		RTE_LCORE_FOREACH_SLAVE(lcore_id) {
+			g_pcap_thread_info.thread_cnt += 1;
 			g_pcap_info[lcore_id].thread_no = thread_no++;
 			rte_eal_remote_launch(slave_main, NULL, lcore_id);
 		}
-- 
2.18.0

