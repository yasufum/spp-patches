From 892a3ef68046e3d61307ea55819daf6f5e1b8d8d Mon Sep 17 00:00:00 2001
From: Yasufumi Ogawa <yasufum.o@gmail.com>
Date: Mon, 22 Jul 2019 11:21:54 +0900
Subject: [PATCH] shared/sec: change names of return codes

This update is to change the names of return codes from `SPP_RET_OK` and
`SPP_RET_NG` to `SPPWK_RET_OK` and `SPPWK_RET_NG` to the namespace is to
be more specific.

Signed-off-by: Yasufumi Ogawa <yasufum.o@gmail.com>
---
 src/shared/secondary/json_helper.c            |  24 +--
 src/shared/secondary/json_helper.h            |  20 +--
 src/shared/secondary/return_codes.h           |   4 +-
 .../secondary/spp_worker_th/cmd_parser.c      | 162 +++++++++---------
 .../secondary/spp_worker_th/cmd_parser.h      |   2 +-
 .../spp_worker_th/cmd_res_formatter.c         | 112 ++++++------
 .../secondary/spp_worker_th/cmd_runner.c      |  50 +++---
 .../secondary/spp_worker_th/cmd_runner.h      |  12 +-
 .../secondary/spp_worker_th/cmd_utils.c       |  54 +++---
 .../secondary/spp_worker_th/cmd_utils.h       |  20 +--
 .../secondary/spp_worker_th/conn_spp_ctl.c    |  16 +-
 .../secondary/spp_worker_th/conn_spp_ctl.h    |  12 +-
 .../secondary/spp_worker_th/mirror_deps.h     |   8 +-
 .../secondary/spp_worker_th/port_capability.c |  20 +--
 .../spp_worker_th/ringlatencystats.c          |   8 +-
 .../spp_worker_th/ringlatencystats.h          |   4 +-
 src/shared/secondary/spp_worker_th/vf_deps.h  |  12 +-
 17 files changed, 270 insertions(+), 270 deletions(-)

diff --git a/src/shared/secondary/json_helper.c b/src/shared/secondary/json_helper.c
index 20badb0..d9e1c4c 100644
--- a/src/shared/secondary/json_helper.c
+++ b/src/shared/secondary/json_helper.c
@@ -14,10 +14,10 @@ append_json_comma(char **output)
 	*output = spp_strbuf_append(*output, ", ", strlen(", "));
 	if (unlikely(*output == NULL)) {
 		RTE_LOG(ERR, WK_JSON_HELPER, "Failed to add comma.\n");
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Add a uint value to given JSON string. */
@@ -32,12 +32,12 @@ append_json_uint_value(char **output, const char *name, unsigned int value)
 		RTE_LOG(ERR, WK_JSON_HELPER,
 				"JSON's numeric format failed to add. "
 				"(name = %s, uint = %u)\n", name, value);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	sprintf(&(*output)[len], JSON_APPEND_VALUE("%u"),
 			JSON_APPEND_COMMA(len), name, value);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Add an int value to given JSON string. */
@@ -52,12 +52,12 @@ append_json_int_value(char **output, const char *name, int value)
 		RTE_LOG(ERR, WK_JSON_HELPER,
 				"JSON's numeric format failed to add. "
 				"(name = %s, int = %d)\n", name, value);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	sprintf(&(*output)[len], JSON_APPEND_VALUE("%d"),
 			JSON_APPEND_COMMA(len), name, value);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Add a string value to given JSON string. */
@@ -72,12 +72,12 @@ append_json_str_value(char **output, const char *name, const char *val)
 		RTE_LOG(ERR, WK_JSON_HELPER,
 				"JSON's string format failed to add. "
 				"(name = %s, val= %s)\n", name, val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	sprintf(&(*output)[len], JSON_APPEND_VALUE("\"%s\""),
 			JSON_APPEND_COMMA(len), name, val);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /**
@@ -96,12 +96,12 @@ append_json_array_brackets(char **output, const char *name, const char *val)
 		RTE_LOG(ERR, WK_JSON_HELPER,
 				"JSON's square bracket failed to add. "
 				"(name = %s, val= %s)\n", name, val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	sprintf(&(*output)[len], JSON_APPEND_ARRAY,
 			JSON_APPEND_COMMA(len), name, val);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /**
@@ -123,7 +123,7 @@ append_json_block_brackets(char **output, const char *name, const char *val)
 		RTE_LOG(ERR, WK_JSON_HELPER,
 				"JSON's curly bracket failed to add. "
 				"(name = %s, val= %s)\n", name, val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	if (name[0] == '\0')
@@ -132,5 +132,5 @@ append_json_block_brackets(char **output, const char *name, const char *val)
 	else
 		sprintf(&(*output)[len], JSON_APPEND_BLOCK,
 				JSON_APPEND_COMMA(len), name, val);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
diff --git a/src/shared/secondary/json_helper.h b/src/shared/secondary/json_helper.h
index b004428..601dc6a 100644
--- a/src/shared/secondary/json_helper.h
+++ b/src/shared/secondary/json_helper.h
@@ -40,8 +40,8 @@ int append_json_comma(char **output);
  * @param[in,out] output Placeholder of JSON msg.
  * @param[in] name Name as a key.
  * @param[in] val Uint value of the key.
- * @retval SPP_RET_OK if succeeded.
- * @retval SPP_RET_NG if failed.
+ * @retval SPPWK_RET_OK if succeeded.
+ * @retval SPPWK_RET_NG if failed.
  */
 int append_json_uint_value(char **output, const char *name, unsigned int val);
 
@@ -51,8 +51,8 @@ int append_json_uint_value(char **output, const char *name, unsigned int val);
  * @param[in,out] output Placeholder of JSON msg.
  * @param[in] name Name as a key.
  * @param[in] val Int value of the key.
- * @retval SPP_RET_OK if succeeded.
- * @retval SPP_RET_NG if failed.
+ * @retval SPPWK_RET_OK if succeeded.
+ * @retval SPPWK_RET_NG if failed.
  */
 int append_json_int_value(char **output, const char *name, int val);
 
@@ -62,8 +62,8 @@ int append_json_int_value(char **output, const char *name, int val);
  * @param[in,out] output Placeholder of JSON msg.
  * @param[in] name Name as a key.
  * @param[in] val String value of the key.
- * @retval SPP_RET_OK if succeeded.
- * @retval SPP_RET_NG if failed.
+ * @retval SPPWK_RET_OK if succeeded.
+ * @retval SPPWK_RET_NG if failed.
  */
 int append_json_str_value(char **output, const char *name, const char *val);
 
@@ -75,8 +75,8 @@ int append_json_str_value(char **output, const char *name, const char *val);
  * @param[in,out] output Placeholder of JSON msg.
  * @param[in] name Name as a key.
  * @param[in] val String value of the key.
- * @retval SPP_RET_OK if succeeded.
- * @retval SPP_RET_NG if failed.
+ * @retval SPPWK_RET_OK if succeeded.
+ * @retval SPPWK_RET_NG if failed.
  */
 int append_json_array_brackets(char **output, const char *name,
 		const char *val);
@@ -92,8 +92,8 @@ int append_json_array_brackets(char **output, const char *name,
  * @param[in,out] output Placeholder of JSON msg.
  * @param[in] name Name as a key.
  * @param[in] val String value of the key.
- * @retval SPP_RET_OK if succeeded.
- * @retval SPP_RET_NG if failed.
+ * @retval SPPWK_RET_OK if succeeded.
+ * @retval SPPWK_RET_NG if failed.
  */
 int append_json_block_brackets(char **output, const char *name,
 		const char *val);
diff --git a/src/shared/secondary/return_codes.h b/src/shared/secondary/return_codes.h
index 18b4711..4ab6ef8 100644
--- a/src/shared/secondary/return_codes.h
+++ b/src/shared/secondary/return_codes.h
@@ -6,8 +6,8 @@
 #define _SPP_SEC_RETURN_CODES_H_
 
 enum spp_return_val {
-	SPP_RET_OK = 0,  /**< succeeded */
-	SPP_RET_NG = -1, /**< failed */
+	SPPWK_RET_OK = 0,  /**< succeeded */
+	SPPWK_RET_NG = -1, /**< failed */
 };
 
 #endif
diff --git a/src/shared/secondary/spp_worker_th/cmd_parser.c b/src/shared/secondary/spp_worker_th/cmd_parser.c
index 84de7e4..9c24407 100644
--- a/src/shared/secondary/spp_worker_th/cmd_parser.c
+++ b/src/shared/secondary/spp_worker_th/cmd_parser.c
@@ -167,14 +167,14 @@ parse_resource_uid(const char *res_uid,
 	} else {
 		RTE_LOG(ERR, WK_CMD_PARSER, "Unexpected port type in '%s'.\n",
 				res_uid);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	int port_id = strtol(iface_no_str, &endptr, 0);
 	if (unlikely(iface_no_str == endptr) || unlikely(*endptr != '\0')) {
 		RTE_LOG(ERR, WK_CMD_PARSER, "No interface number in '%s'.\n",
 				res_uid);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	*iface_type = ptype;
@@ -182,7 +182,7 @@ parse_resource_uid(const char *res_uid,
 
 	RTE_LOG(DEBUG, WK_CMD_PARSER, "Parsed '%s' to '%d' and '%d'.\n",
 			res_uid, *iface_type, *iface_no);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Format error message object and return error code for an error case. */
@@ -227,14 +227,14 @@ split_cmd_params(char *string, int max, int *argc, char *argv[])
 	argv_tok = strtok_r(string, delim, &saveptr);
 	while (argv_tok != NULL) {
 		if (cnt >= max)
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		argv[cnt] = argv_tok;
 		cnt++;
 		argv_tok = strtok_r(NULL, delim, &saveptr);
 	}
 	*argc = cnt;
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Get index of given str from list. */
@@ -246,7 +246,7 @@ get_list_idx(const char *str, const char *list[])
 		if (strcmp(list[i], str) == 0)
 			return i;
 	}
-	return SPP_RET_NG;
+	return SPPWK_RET_NG;
 }
 
 /**
@@ -260,11 +260,11 @@ get_int_in_range(int *output, const char *arg_val, int min, int max)
 	char *endptr = NULL;
 	ret = strtol(arg_val, &endptr, 0);
 	if (unlikely(endptr == arg_val) || unlikely(*endptr != '\0'))
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	if (unlikely(ret < min) || unlikely(ret > max))
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	*output = ret;
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /**
@@ -279,13 +279,13 @@ get_uint_in_range(unsigned int *output, const char *arg_val, unsigned int min,
 	char *endptr = NULL;
 	ret = strtoul(arg_val, &endptr, 0);
 	if (unlikely(endptr == arg_val) || unlikely(*endptr != '\0'))
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	if (unlikely(ret < min) || unlikely(ret > max))
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	*output = ret;
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse given res UID of port and init object of struct sppwk_port_idx. */
@@ -303,9 +303,9 @@ parse_port_uid(void *output, const char *arg_val)
 	if (unlikely(ret != 0)) {
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Invalid resource UID '%s'.\n", arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse given lcore ID. */
@@ -317,9 +317,9 @@ parse_lcore_id(void *output, const char *arg_val)
 	if (unlikely(ret < 0)) {
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Invalid lcore id '%s'.\n", arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse given action in `component` command. */
@@ -334,7 +334,7 @@ parse_comp_action(void *output, const char *arg_val,
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Given invalid cmd `%s`.\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	if (unlikely(ret != SPPWK_ACT_START) &&
@@ -342,11 +342,11 @@ parse_comp_action(void *output, const char *arg_val,
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Unknown component action. val=%s\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	*(int *)output = ret;
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse given name of `arg_val` in `component` command. */
@@ -365,15 +365,15 @@ parse_comp_name(void *output, const char *arg_val,
 			RTE_LOG(ERR, WK_CMD_PARSER,
 					"Comp name '%s' is already used.\n",
 					arg_val);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 	}
 
 	if (strlen(arg_val) >= SPPWK_VAL_BUFSZ)
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	strcpy(component->name, arg_val);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse given lcore ID of `arg_val` in `component` command. */
@@ -385,7 +385,7 @@ parse_comp_lcore_id(void *output, const char *arg_val,
 
 	/* Parsing lcore is required only for action `start`. */
 	if (component->wk_action != SPPWK_ACT_START)
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 
 	return parse_lcore_id(&component->core, arg_val);
 }
@@ -403,18 +403,18 @@ parse_comp_type(void *output, const char *arg_val,
 
 	/* Parsing comp type is required only for action `start`. */
 	if (component->wk_action != SPPWK_ACT_START)
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 
 	comp_type = get_comp_type_from_str(arg_val);
 	if (unlikely(comp_type <= 0)) {
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Unknown component type '%s'.\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	component->wk_type = comp_type;
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse given action for port of `arg_val` in `port` command. */
@@ -429,7 +429,7 @@ parse_port_action(void *output, const char *arg_val,
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Unknown port action. val=%s\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	/* TODO(yasufum) fix not explicit checking this condition. */
@@ -438,11 +438,11 @@ parse_port_action(void *output, const char *arg_val,
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Unknown port action. val=%s\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	*(int *)output = ret;  /* TODO(yasufum) confirm the statement is OK. */
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse given port uid in port command. */
@@ -454,8 +454,8 @@ parse_port(void *output, const char *arg_val, int allow_override)
 	struct sppwk_cmd_port *port = output;
 
 	ret = parse_port_uid(&tmp_port, arg_val);
-	if (ret < SPP_RET_OK)
-		return SPP_RET_NG;
+	if (ret < SPPWK_RET_OK)
+		return SPPWK_RET_NG;
 
 	/* If action is `add`, check the port is already used for rx and tx. */
 	if (allow_override == 0) {
@@ -469,13 +469,13 @@ parse_port(void *output, const char *arg_val, int allow_override)
 			RTE_LOG(ERR, WK_CMD_PARSER,
 				"Port `%s` is already used.\n",
 				arg_val);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 	}
 
 	port->port.iface_type = tmp_port.iface_type;
 	port->port.iface_no   = tmp_port.iface_no;
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse port rx and tx value. */
@@ -489,7 +489,7 @@ parse_port_direction(void *output, const char *arg_val, int allow_override)
 	if (unlikely(ret <= 0)) {
 		RTE_LOG(ERR, WK_CMD_PARSER, "Unknown port direction. val=%s\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	/* add vlantag command check */
@@ -500,12 +500,12 @@ parse_port_direction(void *output, const char *arg_val, int allow_override)
 			RTE_LOG(ERR, WK_CMD_PARSER,
 				"Port in used. (port command) val=%s\n",
 				arg_val);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 	}
 
 	port->dir = ret;
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse comp name for `port` command. */
@@ -514,21 +514,21 @@ static int
 parse_comp_name_portcmd(void *output, const char *arg_val,
 				int allow_override __attribute__ ((unused)))
 {
-	int ret = SPP_RET_OK;
+	int ret = SPPWK_RET_OK;
 
 	/* Check if lcore is already used. */
 	ret = sppwk_get_lcore_id(arg_val);  /* Get lcore ID. */
-	if (unlikely(ret < SPP_RET_OK)) {
+	if (unlikely(ret < SPPWK_RET_OK)) {
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Unknown component name. val=%s\n", arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	if (strlen(arg_val) >= SPPWK_VAL_BUFSZ)
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	strcpy(output, arg_val);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse vlan operation for port command. */
@@ -549,7 +549,7 @@ parse_port_vlan_ops(void *output, const char *arg_val,
 			RTE_LOG(ERR, WK_CMD_PARSER,
 					"Unknown port attribute. val=%s\n",
 					arg_val);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 		port_attrs->ops = ret;
 		port_attrs->dir = port->dir;
@@ -562,7 +562,7 @@ parse_port_vlan_ops(void *output, const char *arg_val,
 		break;
 	}
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse VLAN ID  for port command. */
@@ -578,11 +578,11 @@ parse_port_vid(void *output, const char *arg_val,
 	case SPPWK_PORT_OPS_ADD_VLAN:
 		vlan_id = get_int_in_range(&port_attrs->capability.vlantag.vid,
 			arg_val, 0, ETH_VLAN_ID_MAX);
-		if (unlikely(vlan_id < SPP_RET_OK)) {
+		if (unlikely(vlan_id < SPPWK_RET_OK)) {
 			RTE_LOG(ERR, WK_CMD_PARSER,
 					"Invalid `%s` for parsing VLAN ID.\n",
 					arg_val);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 		port_attrs->capability.vlantag.pcp = -1;
 		break;
@@ -591,7 +591,7 @@ parse_port_vid(void *output, const char *arg_val,
 		break;
 	}
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse PCP for port command */
@@ -607,11 +607,11 @@ parse_port_pcp(void *output, const char *arg_val,
 	case SPPWK_PORT_OPS_ADD_VLAN:
 		pcp = get_int_in_range(&port_attrs->capability.vlantag.pcp,
 				arg_val, 0, SPP_VLAN_PCP_MAX);
-		if (unlikely(pcp < SPP_RET_OK)) {
+		if (unlikely(pcp < SPPWK_RET_OK)) {
 			RTE_LOG(ERR, WK_CMD_PARSER,
 					"Invalid `%s`for parsing PCP.\n",
 					arg_val);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 		break;
 	default:
@@ -619,7 +619,7 @@ parse_port_pcp(void *output, const char *arg_val,
 		break;
 	}
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse mac address string. */
@@ -636,14 +636,14 @@ parse_mac_addr(void *output, const char *arg_val,
 
 	/* Check if the given value is valid. */
 	res = sppwk_convert_mac_str_to_int64(str_val);
-	if (unlikely(res < SPP_RET_OK)) {
+	if (unlikely(res < SPPWK_RET_OK)) {
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Invalid MAC address `%s`.\n", str_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	strcpy((char *)output, str_val);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /**
@@ -660,7 +660,7 @@ parse_cls_action(void *output, const char *arg_val,
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Failed to get index for action `%s`.\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	if (unlikely(idx != SPPWK_ACT_ADD) &&
@@ -668,11 +668,11 @@ parse_cls_action(void *output, const char *arg_val,
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Unknown action `%s` for port.\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	*(int *)output = idx;
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse cls type and get index for classifier_table command. */
@@ -686,11 +686,11 @@ parse_cls_type(void *output, const char *arg_val,
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Unknown classifier type. val=%s\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	*(int *)output = idx;
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse VLAN ID for classifier_table command. */
@@ -700,12 +700,12 @@ parse_cls_vid(void *output, const char *arg_val,
 {
 	int idx;
 	idx = get_int_in_range(output, arg_val, 0, ETH_VLAN_ID_MAX);
-	if (unlikely(idx < SPP_RET_OK)) {
+	if (unlikely(idx < SPPWK_RET_OK)) {
 		RTE_LOG(ERR, WK_CMD_PARSER, "Invalid VLAN ID `%s`.\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Parse port for classifier_table command */
@@ -713,19 +713,19 @@ static int
 parse_cls_port(void *cls_cmd_attr, const char *arg_val,
 		int allow_override __attribute__ ((unused)))
 {
-	int ret = SPP_RET_OK;
+	int ret = SPPWK_RET_OK;
 	struct sppwk_cls_cmd_attrs *cls_attrs = cls_cmd_attr;
 	struct sppwk_port_idx tmp_port;
 	int64_t mac_addr = 0;
 
 	ret = parse_port_uid(&tmp_port, arg_val);
-	if (ret < SPP_RET_OK)
-		return SPP_RET_NG;
+	if (ret < SPPWK_RET_OK)
+		return SPPWK_RET_NG;
 
 	if (is_added_port(tmp_port.iface_type, tmp_port.iface_no) == 0) {
 		RTE_LOG(ERR, WK_CMD_PARSER, "Port not added. val=%s\n",
 				arg_val);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	if (cls_attrs->cls_type == SPPWK_CLS_TYPE_MAC)
@@ -737,12 +737,12 @@ parse_cls_port(void *cls_cmd_attr, const char *arg_val,
 			RTE_LOG(ERR, WK_CMD_PARSER, "Port in used. "
 					"(classifier_table command) val=%s\n",
 					arg_val);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 	} else if (unlikely(cls_attrs->wk_action == SPPWK_ACT_DEL)) {
 		mac_addr = sppwk_convert_mac_str_to_int64(cls_attrs->mac);
 		if (mac_addr < 0)
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 
 		if (!is_used_with_addr(cls_attrs->vid,
 				(uint64_t)mac_addr,
@@ -750,13 +750,13 @@ parse_cls_port(void *cls_cmd_attr, const char *arg_val,
 			RTE_LOG(ERR, WK_CMD_PARSER, "Port in used. "
 					"(classifier_table command) val=%s\n",
 					arg_val);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 	}
 
 	cls_attrs->port.iface_type = tmp_port.iface_type;
 	cls_attrs->port.iface_no   = tmp_port.iface_no;
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Attributes operator functions of command for parsing. */
@@ -909,7 +909,7 @@ parse_cmd_comp(struct sppwk_cmd_req *request, int argc, char *argv[],
 		struct sppwk_parse_err_msg *wk_err_msg,
 		int maxargc __attribute__ ((unused)))
 {
-	int ret = SPP_RET_OK;
+	int ret = SPPWK_RET_OK;
 	int ci = request->commands[0].type;
 	int pi = 0;
 	struct sppwk_cmd_ops *list = NULL;
@@ -927,7 +927,7 @@ parse_cmd_comp(struct sppwk_cmd_req *request, int argc, char *argv[],
 					list->name, argv[pi]);
 		}
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Validate given command for clssfier_table. */
@@ -944,7 +944,7 @@ parse_cmd_cls_table_vlan(struct sppwk_cmd_req *request, int argc, char *argv[],
 		struct sppwk_parse_err_msg *wk_err_msg,
 		int maxargc __attribute__ ((unused)))
 {
-	int ret = SPP_RET_OK;
+	int ret = SPPWK_RET_OK;
 	int ci = request->commands[0].type;
 	int pi = 0;
 	struct sppwk_cmd_ops *list = NULL;
@@ -953,7 +953,7 @@ parse_cmd_cls_table_vlan(struct sppwk_cmd_req *request, int argc, char *argv[],
 		ret = (*list->func)((void *)
 				((char *)&request->commands[0] + list->offset),
 				argv[pi], 0);
-		if (unlikely(ret < SPP_RET_OK)) {
+		if (unlikely(ret < SPPWK_RET_OK)) {
 			RTE_LOG(ERR, WK_CMD_PARSER, "Bad value. "
 				"command=%s, name=%s, index=%d, value=%s\n",
 					argv[0], list->name, pi, argv[pi]);
@@ -961,7 +961,7 @@ parse_cmd_cls_table_vlan(struct sppwk_cmd_req *request, int argc, char *argv[],
 					list->name, argv[pi]);
 		}
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Validate given command for port. */
@@ -969,7 +969,7 @@ static int
 parse_cmd_port(struct sppwk_cmd_req *request, int argc, char *argv[],
 		struct sppwk_parse_err_msg *wk_err_msg, int maxargc)
 {
-	int ret = SPP_RET_OK;
+	int ret = SPPWK_RET_OK;
 	int ci = request->commands[0].type;
 	int pi = 0;
 	struct sppwk_cmd_ops *list = NULL;
@@ -984,7 +984,7 @@ parse_cmd_port(struct sppwk_cmd_req *request, int argc, char *argv[],
 		ret = (*list->func)((void *)
 				((char *)&request->commands[0] + list->offset),
 				argv[pi], flag);
-		if (unlikely(ret < SPP_RET_OK)) {
+		if (unlikely(ret < SPPWK_RET_OK)) {
 			RTE_LOG(ERR, WK_CMD_PARSER, "Bad value. "
 				"command=%s, name=%s, index=%d, value=%s\n",
 					argv[0], list->name, pi, argv[pi]);
@@ -992,7 +992,7 @@ parse_cmd_port(struct sppwk_cmd_req *request, int argc, char *argv[],
 					list->name, argv[pi]);
 		}
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /**
@@ -1029,7 +1029,7 @@ parse_wk_cmd(struct sppwk_cmd_req *request,
 		const char *request_str,
 		struct sppwk_parse_err_msg *wk_err_msg)
 {
-	int ret = SPP_RET_OK;
+	int ret = SPPWK_RET_OK;
 	int is_valid_nof_params = 1;  /* for checking nof params in range. */
 	struct cmd_parse_attrs *list = NULL;
 	int i = 0;
@@ -1053,7 +1053,7 @@ parse_wk_cmd(struct sppwk_cmd_req *request,
 	 * itself is done in the next step as following. No need to do here.
 	 */
 	ret = split_cmd_params(tmp_str, SPPWK_MAX_PARAMS, &argc, argv);
-	if (ret < SPP_RET_OK) {
+	if (ret < SPPWK_RET_OK) {
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Num of params should be less than %d. "
 				"request_str=%s\n",
@@ -1079,7 +1079,7 @@ parse_wk_cmd(struct sppwk_cmd_req *request,
 			return (*list->func)(request, argc, argv, wk_err_msg,
 							list->nof_params_max);
 
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 	}
 
 	/**
@@ -1107,13 +1107,13 @@ sppwk_parse_req(
 		const char *request_str, size_t request_str_len,
 		struct sppwk_parse_err_msg *wk_err_msg)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	int i;
 
 	/* decode request */
 	request->nof_cmds = 1;
 	ret = parse_wk_cmd(request, request_str, wk_err_msg);
-	if (unlikely(ret != SPP_RET_OK)) {
+	if (unlikely(ret != SPPWK_RET_OK)) {
 		RTE_LOG(ERR, WK_CMD_PARSER,
 				"Cannot decode command request. "
 				"ret=%d, request_str=%.*s\n",
diff --git a/src/shared/secondary/spp_worker_th/cmd_parser.h b/src/shared/secondary/spp_worker_th/cmd_parser.h
index e51c3a4..ae9f225 100644
--- a/src/shared/secondary/spp_worker_th/cmd_parser.h
+++ b/src/shared/secondary/spp_worker_th/cmd_parser.h
@@ -152,7 +152,7 @@ struct sppwk_parse_err_msg {
  *  The pointer to struct sppwk_parse_err_msg.@n
  *  Detailed error information will be stored.
  *
- * @retval SPP_RET_OK succeeded.
+ * @retval SPPWK_RET_OK succeeded.
  * @retval !0 failed.
  */
 int sppwk_parse_req(struct sppwk_cmd_req *request,
diff --git a/src/shared/secondary/spp_worker_th/cmd_res_formatter.c b/src/shared/secondary/spp_worker_th/cmd_res_formatter.c
index de7acaf..eb04241 100644
--- a/src/shared/secondary/spp_worker_th/cmd_res_formatter.c
+++ b/src/shared/secondary/spp_worker_th/cmd_res_formatter.c
@@ -52,24 +52,24 @@ append_result_value(const char *name, char **output, void *tmp)
 static int
 append_error_details_value(const char *name, char **output, void *tmp)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	const struct cmd_result *result = tmp;
 	char *tmp_buff;
 	/* string is empty, except for errors */
 	if (result->err_msg[0] == '\0')
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 
 	tmp_buff = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
 	if (unlikely(tmp_buff == NULL)) {
 		RTE_LOG(ERR, WK_CMD_RES_FMT,
 				"Fail to alloc buf for `%s`.\n", name);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	ret = append_json_str_value(&tmp_buff, "message", result->err_msg);
 	if (unlikely(ret < 0)) {
 		spp_strbuf_free(tmp_buff);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	ret = append_json_block_brackets(output, name, tmp_buff);
@@ -103,11 +103,11 @@ append_interface_array(char **output, const enum port_type type)
 			RTE_LOG(ERR, WK_CMD_RES_FMT,
 				/* TODO(yasufum) replace %d to string. */
 				"Failed to add index for type `%d`.\n", type);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 		port_cnt++;
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* append a secondary process type for JSON format */
@@ -122,21 +122,21 @@ append_process_type_value(const char *name, char **output,
 int
 append_vlan_value(char **output, const int ope, const int vid, const int pcp)
 {
-	int ret = SPP_RET_OK;
+	int ret = SPPWK_RET_OK;
 	ret = append_json_str_value(output, "operation",
 			PORT_ABILITY_STAT_LIST[ope]);
-	if (unlikely(ret < SPP_RET_OK))
-		return SPP_RET_NG;
+	if (unlikely(ret < SPPWK_RET_OK))
+		return SPPWK_RET_NG;
 
 	ret = append_json_int_value(output, "id", vid);
 	if (unlikely(ret < 0))
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	ret = append_json_int_value(output, "pcp", pcp);
 	if (unlikely(ret < 0))
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* append a block of vlan for JSON format */
@@ -144,7 +144,7 @@ int
 append_vlan_block(const char *name, char **output,
 		const int port_id, const enum sppwk_port_dir dir)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	int i = 0;
 	struct sppwk_port_attrs *port_attrs = NULL;
 	char *tmp_buff = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
@@ -152,7 +152,7 @@ append_vlan_block(const char *name, char **output,
 		RTE_LOG(ERR, WK_CMD_RES_FMT,
 				"Failed to allocate buffer (name = %s).\n",
 				name);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	sppwk_get_port_attrs(&port_attrs, port_id, dir);
@@ -163,8 +163,8 @@ append_vlan_block(const char *name, char **output,
 			ret = append_vlan_value(&tmp_buff, port_attrs[i].ops,
 					port_attrs[i].capability.vlantag.vid,
 					port_attrs[i].capability.vlantag.pcp);
-			if (unlikely(ret < SPP_RET_OK))
-				return SPP_RET_NG;
+			if (unlikely(ret < SPPWK_RET_OK))
+				return SPPWK_RET_NG;
 
 			/*
 			 * Change counter to "maximum+1" for exit the loop.
@@ -181,8 +181,8 @@ append_vlan_block(const char *name, char **output,
 	if (i == PORT_ABL_MAX) {
 		ret = append_vlan_value(&tmp_buff, SPPWK_PORT_OPS_NONE,
 				0, 0);
-		if (unlikely(ret < SPP_RET_OK))
-			return SPP_RET_NG;
+		if (unlikely(ret < SPPWK_RET_OK))
+			return SPPWK_RET_NG;
 	}
 
 	ret = append_json_block_brackets(output, name, tmp_buff);
@@ -208,7 +208,7 @@ get_ethdev_port_id(enum port_type iface_type, int iface_no)
 	case VHOST:
 		return iface_info->vhost[iface_no].ethdev_port_id;
 	default:
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 }
 
@@ -217,27 +217,27 @@ int
 append_port_block(char **output, const struct sppwk_port_idx *port,
 		const enum sppwk_port_dir dir)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	char port_str[CMD_TAG_APPEND_SIZE];
 	char *tmp_buff = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
 	if (unlikely(tmp_buff == NULL)) {
 		RTE_LOG(ERR, WK_CMD_RES_FMT,
 				/* TODO(yasufum) refactor no meaning err msg */
 				"allocate error. (name = port_block)\n");
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	sppwk_port_uid(port_str, port->iface_type, port->iface_no);
 	ret = append_json_str_value(&tmp_buff, "port", port_str);
-	if (unlikely(ret < SPP_RET_OK))
-		return SPP_RET_NG;
+	if (unlikely(ret < SPPWK_RET_OK))
+		return SPPWK_RET_NG;
 
 	ret = append_vlan_block("vlan", &tmp_buff,
 			get_ethdev_port_id(
 				port->iface_type, port->iface_no),
 			dir);
-	if (unlikely(ret < SPP_RET_OK))
-		return SPP_RET_NG;
+	if (unlikely(ret < SPPWK_RET_OK))
+		return SPPWK_RET_NG;
 
 	ret = append_json_block_brackets(output, "", tmp_buff);
 	spp_strbuf_free(tmp_buff);
@@ -250,7 +250,7 @@ append_port_array(const char *name, char **output, const int num,
 		const struct sppwk_port_idx *ports,
 		const enum sppwk_port_dir dir)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	int i = 0;
 	char *tmp_buff = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
 	if (unlikely(tmp_buff == NULL)) {
@@ -258,13 +258,13 @@ append_port_array(const char *name, char **output, const int num,
 				/* TODO(yasufum) refactor no meaning err msg */
 				"allocate error. (name = %s)\n",
 				name);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	for (i = 0; i < num; i++) {
 		ret = append_port_block(&tmp_buff, &ports[i], dir);
-		if (unlikely(ret < SPP_RET_OK))
-			return SPP_RET_NG;
+		if (unlikely(ret < SPPWK_RET_OK))
+			return SPPWK_RET_NG;
 	}
 
 	ret = append_json_array_brackets(output, name, tmp_buff);
@@ -285,7 +285,7 @@ append_core_element_value(
 		const int num_rx, const struct sppwk_port_idx *rx_ports,
 		const int num_tx, const struct sppwk_port_idx *tx_ports)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	int unuse_flg = 0;
 	char *buff, *tmp_buff;
 	buff = params->output;
@@ -306,7 +306,7 @@ append_core_element_value(
 	 * "worker-lcores" or "slave-lcores".
 	 */
 	ret = append_json_uint_value(&tmp_buff, "core", lcore_id);
-	if (unlikely(ret < SPP_RET_OK))
+	if (unlikely(ret < SPPWK_RET_OK))
 		return ret;
 
 	if (unuse_flg) {
@@ -316,7 +316,7 @@ append_core_element_value(
 	}
 
 	ret = append_json_str_value(&tmp_buff, "type", type);
-	if (unlikely(ret < SPP_RET_OK))
+	if (unlikely(ret < SPPWK_RET_OK))
 		return ret;
 
 	if (unuse_flg) {
@@ -327,7 +327,7 @@ append_core_element_value(
 
 		ret = append_port_array("tx_port", &tmp_buff,
 				num_tx, tx_ports, SPPWK_PORT_DIR_TX);
-		if (unlikely(ret < SPP_RET_OK))
+		if (unlikely(ret < SPPWK_RET_OK))
 			return ret;
 	}
 
@@ -342,7 +342,7 @@ int
 append_response_list_value(char **output,
 		struct cmd_res_formatter_ops *responses, void *tmp)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	int i;
 	char *tmp_buff;
 	tmp_buff = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
@@ -350,18 +350,18 @@ append_response_list_value(char **output,
 		RTE_LOG(ERR, WK_CMD_RES_FMT,
 				/* TODO(yasufum) refactor no meaning err msg */
 				"allocate error. (name = response_list)\n");
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	for (i = 0; responses[i].tag_name[0] != '\0'; i++) {
 		tmp_buff[0] = '\0';
 		ret = responses[i].func(responses[i].tag_name, &tmp_buff, tmp);
-		if (unlikely(ret < SPP_RET_OK)) {
+		if (unlikely(ret < SPPWK_RET_OK)) {
 			spp_strbuf_free(tmp_buff);
 			RTE_LOG(ERR, WK_CMD_RES_FMT,
 					"Failed to get reply string. "
 					"(tag = %s)\n", responses[i].tag_name);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 
 		if (tmp_buff[0] == '\0')
@@ -369,13 +369,13 @@ append_response_list_value(char **output,
 
 		if ((*output)[0] != '\0') {
 			ret = append_json_comma(output);
-			if (unlikely(ret < SPP_RET_OK)) {
+			if (unlikely(ret < SPPWK_RET_OK)) {
 				spp_strbuf_free(tmp_buff);
 				RTE_LOG(ERR, WK_CMD_RES_FMT,
 						"Failed to add commas. "
 						"(tag = %s)\n",
 						responses[i].tag_name);
-				return SPP_RET_NG;
+				return SPPWK_RET_NG;
 			}
 		}
 
@@ -387,12 +387,12 @@ append_response_list_value(char **output,
 					"Failed to add reply string. "
 					"(tag = %s)\n",
 					responses[i].tag_name);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 	}
 
 	spp_strbuf_free(tmp_buff);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /**
@@ -403,7 +403,7 @@ int
 append_command_results_value(const char *name, char **output,
 		int num, struct cmd_result *results)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	int i;
 	char *tmp_buff1, *tmp_buff2;
 
@@ -412,14 +412,14 @@ append_command_results_value(const char *name, char **output,
 	if (unlikely(tmp_buff1 == NULL)) {
 		RTE_LOG(ERR, WK_CMD_RES_FMT,
 				"Faield to alloc 1st buf for `%s`.\n", name);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 	tmp_buff2 = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
 	if (unlikely(tmp_buff2 == NULL)) {
 		spp_strbuf_free(tmp_buff1);
 		RTE_LOG(ERR, WK_CMD_RES_FMT,
 				"Faield to alloc 2nd buf for `%s`.\n", name);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	for (i = 0; i < num; i++) {
@@ -431,7 +431,7 @@ append_command_results_value(const char *name, char **output,
 		if (unlikely(ret < 0)) {
 			spp_strbuf_free(tmp_buff1);
 			spp_strbuf_free(tmp_buff2);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 
 		/* Surround key-val pair such as `{ "result": "success" }`. */
@@ -439,7 +439,7 @@ append_command_results_value(const char *name, char **output,
 		if (unlikely(ret < 0)) {
 			spp_strbuf_free(tmp_buff1);
 			spp_strbuf_free(tmp_buff2);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 	}
 
@@ -472,7 +472,7 @@ append_command_results_value(const char *name, char **output,
 int
 append_info_value(const char *name, char **output)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	char *tmp_buff = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
 	struct cmd_res_formatter_ops ops_list[NOF_STAT_OPS];
 
@@ -480,7 +480,7 @@ append_info_value(const char *name, char **output)
 		RTE_LOG(ERR, WK_CMD_RES_FMT,
 				"Failed to get empty buf for append `%s`.\n",
 				name);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	memset(ops_list, 0x00,
@@ -490,14 +490,14 @@ append_info_value(const char *name, char **output)
 	if (unlikely(is_got_ops < 0)) {
 		RTE_LOG(ERR, WK_CMD_RES_FMT,
 				"Failed to get ops_list.\n");
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	/* Setup JSON msg in value of `info` key. */
 	ret = append_response_list_value(&tmp_buff, ops_list, NULL);
-	if (unlikely(ret < SPP_RET_OK)) {
+	if (unlikely(ret < SPPWK_RET_OK)) {
 		spp_strbuf_free(tmp_buff);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	/* Setup response of JSON msg. */
@@ -525,14 +525,14 @@ int
 add_interface(const char *name, char **output,
 		void *tmp __attribute__ ((unused)))
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	char *tmp_buff = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
 	if (unlikely(tmp_buff == NULL)) {
 		RTE_LOG(ERR, WK_CMD_RES_FMT,
 				/* TODO(yasufum) refactor no meaning err msg */
 				"allocate error. (name = %s)\n",
 				name);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	if (strcmp(name, SPPWK_PHY_STR) == 0)
@@ -544,9 +544,9 @@ add_interface(const char *name, char **output,
 	else if (strcmp(name, SPPWK_RING_STR) == 0)
 		ret = append_interface_array(&tmp_buff, RING);
 
-	if (unlikely(ret < SPP_RET_OK)) {
+	if (unlikely(ret < SPPWK_RET_OK)) {
 		spp_strbuf_free(tmp_buff);
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	ret = append_json_array_brackets(output, name, tmp_buff);
@@ -559,7 +559,7 @@ int
 add_master_lcore(const char *name, char **output,
 		void *tmp __attribute__ ((unused)))
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	ret = append_json_int_value(output, name, rte_get_master_lcore());
 	return ret;
 }
diff --git a/src/shared/secondary/spp_worker_th/cmd_runner.c b/src/shared/secondary/spp_worker_th/cmd_runner.c
index d11dfc9..094019f 100644
--- a/src/shared/secondary/spp_worker_th/cmd_runner.c
+++ b/src/shared/secondary/spp_worker_th/cmd_runner.c
@@ -47,7 +47,7 @@ flush_cmd(void)
 			&backup_info);
 
 	ret = update_port_info();
-	if (ret < SPP_RET_OK)
+	if (ret < SPPWK_RET_OK)
 		return ret;
 
 	/* TODO(yasufum) confirm why no returned value. */
@@ -156,7 +156,7 @@ send_decode_error_response(int *sock,
 		const struct sppwk_cmd_req *request,
 		struct cmd_result *cmd_results)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	char *msg, *tmp_buff;
 	tmp_buff = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
 	if (unlikely(tmp_buff == NULL)) {
@@ -169,7 +169,7 @@ send_decode_error_response(int *sock,
 	/* create & append result array */
 	ret = append_command_results_value("results", &tmp_buff,
 			request->nof_cmds, cmd_results);
-	if (unlikely(ret < SPP_RET_OK)) {
+	if (unlikely(ret < SPPWK_RET_OK)) {
 		spp_strbuf_free(tmp_buff);
 		RTE_LOG(ERR, WK_CMD_RUNNER,
 				"Failed to make command result response.\n");
@@ -186,7 +186,7 @@ send_decode_error_response(int *sock,
 	}
 	ret = append_json_block_brackets(&msg, "", tmp_buff);
 	spp_strbuf_free(tmp_buff);
-	if (unlikely(ret < SPP_RET_OK)) {
+	if (unlikely(ret < SPPWK_RET_OK)) {
 		spp_strbuf_free(msg);
 		RTE_LOG(ERR, WK_CMD_RUNNER,
 				/* TODO(yasufum) refactor no meaning err msg */
@@ -200,7 +200,7 @@ send_decode_error_response(int *sock,
 
 	/* send response to requester */
 	ret = send_ctl_msg(sock, msg, strlen(msg));
-	if (unlikely(ret != SPP_RET_OK)) {
+	if (unlikely(ret != SPPWK_RET_OK)) {
 		RTE_LOG(ERR, WK_CMD_RUNNER,
 				"Failed to send decode error response.\n");
 		/* not return */
@@ -215,7 +215,7 @@ send_result_spp_ctl(int *sock,
 		const struct sppwk_cmd_req *request,
 		struct cmd_result *cmd_results)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	char *msg, *tmp_buff;
 	tmp_buff = spp_strbuf_allocate(CMD_RES_BUF_INIT_SIZE);
 	if (unlikely(tmp_buff == NULL)) {
@@ -228,7 +228,7 @@ send_result_spp_ctl(int *sock,
 	/* create & append result array */
 	ret = append_command_results_value("results", &tmp_buff,
 			request->nof_cmds, cmd_results);
-	if (unlikely(ret < SPP_RET_OK)) {
+	if (unlikely(ret < SPPWK_RET_OK)) {
 		spp_strbuf_free(tmp_buff);
 		RTE_LOG(ERR, WK_CMD_RUNNER,
 				"Failed to make command result response.\n");
@@ -238,7 +238,7 @@ send_result_spp_ctl(int *sock,
 	/* append client id information value */
 	if (request->is_requested_client_id) {
 		ret = add_client_id("client_id", &tmp_buff, NULL);
-		if (unlikely(ret < SPP_RET_OK)) {
+		if (unlikely(ret < SPPWK_RET_OK)) {
 			spp_strbuf_free(tmp_buff);
 			RTE_LOG(ERR, WK_CMD_RUNNER, "Failed to make "
 					"client id response.\n");
@@ -251,7 +251,7 @@ send_result_spp_ctl(int *sock,
 	/* append info value */
 	if (request->is_requested_status) {
 		ret = append_info_value("info", &tmp_buff);
-		if (unlikely(ret < SPP_RET_OK)) {
+		if (unlikely(ret < SPPWK_RET_OK)) {
 			spp_strbuf_free(tmp_buff);
 			RTE_LOG(ERR, WK_CMD_RUNNER,
 					"Failed to make status response.\n");
@@ -269,7 +269,7 @@ send_result_spp_ctl(int *sock,
 	}
 	ret = append_json_block_brackets(&msg, "", tmp_buff);
 	spp_strbuf_free(tmp_buff);
-	if (unlikely(ret < SPP_RET_OK)) {
+	if (unlikely(ret < SPPWK_RET_OK)) {
 		spp_strbuf_free(msg);
 		RTE_LOG(ERR, WK_CMD_RUNNER,
 				/* TODO(yasufum) refactor no meaning err msg */
@@ -283,7 +283,7 @@ send_result_spp_ctl(int *sock,
 
 	/* send response to requester */
 	ret = send_ctl_msg(sock, msg, strlen(msg));
-	if (unlikely(ret != SPP_RET_OK)) {
+	if (unlikely(ret != SPPWK_RET_OK)) {
 		RTE_LOG(ERR, WK_CMD_RUNNER,
 			"Failed to send command result response.\n");
 		/* not return */
@@ -296,7 +296,7 @@ send_result_spp_ctl(int *sock,
 static int
 exec_cmds(int *sock, const char *req_str, size_t req_str_len)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	int i;
 
 	struct sppwk_cmd_req cmd_req;
@@ -312,12 +312,12 @@ exec_cmds(int *sock, const char *req_str, size_t req_str_len)
 			(int)req_str_len, req_str);
 	ret = sppwk_parse_req(&cmd_req, req_str, req_str_len, &wk_err_msg);
 
-	if (unlikely(ret != SPP_RET_OK)) {
+	if (unlikely(ret != SPPWK_RET_OK)) {
 		/* Setup and send error response. */
 		prepare_parse_err_msg(cmd_results, &cmd_req, &wk_err_msg);
 		send_decode_error_response(sock, &cmd_req, cmd_results);
 		RTE_LOG(DEBUG, WK_CMD_RUNNER, "Failed to parse cmds.\n");
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 	}
 
 	RTE_LOG(DEBUG, WK_CMD_RUNNER,
@@ -327,7 +327,7 @@ exec_cmds(int *sock, const char *req_str, size_t req_str_len)
 	/* execute commands */
 	for (i = 0; i < cmd_req.nof_cmds; ++i) {
 		ret = exec_one_cmd(cmd_req.commands + i);
-		if (unlikely(ret != SPP_RET_OK)) {
+		if (unlikely(ret != SPPWK_RET_OK)) {
 			set_cmd_result(&cmd_results[i], CMD_FAILED,
 					"error occur");
 			/* Does not execute remaining commands */
@@ -346,7 +346,7 @@ exec_cmds(int *sock, const char *req_str, size_t req_str_len)
 		send_result_spp_ctl(sock, &cmd_req, cmd_results);
 		RTE_LOG(INFO, WK_CMD_RUNNER,
 				"Process is terminated with exit cmd.\n");
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	/* Send response to spp-ctl. */
@@ -354,7 +354,7 @@ exec_cmds(int *sock, const char *req_str, size_t req_str_len)
 
 	RTE_LOG(DEBUG, WK_CMD_RUNNER, "End command request processing.\n");
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Setup connection for accepting commands from spp-ctl. */
@@ -380,23 +380,23 @@ sppwk_run_cmd(void)
 			RTE_LOG(ERR, WK_CMD_RUNNER,
 					"Cannot allocate memory "
 					"for receive data(init).\n");
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 	}
 
 	ret = conn_spp_ctl(&sock);
 
-	if (unlikely(ret != SPP_RET_OK))
-		return SPP_RET_OK;
+	if (unlikely(ret != SPPWK_RET_OK))
+		return SPPWK_RET_OK;
 
 	msg_ret = recv_ctl_msg(&sock, &msgbuf);
 	if (unlikely(msg_ret <= 0)) {
 		if (likely(msg_ret == 0))
-			return SPP_RET_OK;
+			return SPPWK_RET_OK;
 		else if (unlikely(msg_ret == SPP_CONNERR_TEMPORARY))
-			return SPP_RET_OK;
+			return SPPWK_RET_OK;
 		else
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 	}
 
 	ret = exec_cmds(&sock, msgbuf, msg_ret);
@@ -418,7 +418,7 @@ del_comp_info(int lcore_id, int nof_comps, int *comp_ary)
 			idx = cnt;
 	}
 	if (idx < 0)
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	/* Overwrite the deleted entry, and shift the remained. */
 	nof_comps--;
@@ -428,5 +428,5 @@ del_comp_info(int lcore_id, int nof_comps, int *comp_ary)
 	/* Clean the unused last entry. */
 	comp_ary[cnt] = 0;
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
diff --git a/src/shared/secondary/spp_worker_th/cmd_runner.h b/src/shared/secondary/spp_worker_th/cmd_runner.h
index e13e936..fcd4559 100644
--- a/src/shared/secondary/spp_worker_th/cmd_runner.h
+++ b/src/shared/secondary/spp_worker_th/cmd_runner.h
@@ -27,8 +27,8 @@ int flush_cmd(void);
  * @param ctl_port
  * Port number of spp-ctl.
  *
- * @retval SPP_RET_OK if succeeded.
- * @retval SPP_RET_NG if failed.
+ * @retval SPPWK_RET_OK if succeeded.
+ * @retval SPPWK_RET_NG if failed.
  */
 int
 sppwk_cmd_runner_conn(const char *ctl_ipaddr, int ctl_port);
@@ -36,9 +36,9 @@ sppwk_cmd_runner_conn(const char *ctl_ipaddr, int ctl_port);
 /**
  * Run command sent from spp-ctl.
  *
- * @retval SPP_RET_OK if succeeded.
+ * @retval SPPWK_RET_OK if succeeded.
  * TODO(yasufum) change exclude case of exit cmd because it is not NG.
- * @retval SPP_RET_NG if connection failure or received exit command.
+ * @retval SPPWK_RET_NG if connection failure or received exit command.
  */
 int
 sppwk_run_cmd(void);
@@ -50,8 +50,8 @@ sppwk_run_cmd(void);
  * @param[in] nof_comps The num of elements in comp_ary.
  * @param[in] *comp_ary Set of comps from which an comp is deleted.
  *
- * @retval SPP_RET_OK If succeeded.
- * @retval SPP_RET_NG If failed.
+ * @retval SPPWK_RET_OK If succeeded.
+ * @retval SPPWK_RET_NG If failed.
  */
 int
 del_comp_info(int lcore_id, int nof_comps, int *comp_ary);
diff --git a/src/shared/secondary/spp_worker_th/cmd_utils.c b/src/shared/secondary/spp_worker_th/cmd_utils.c
index 9180169..c879e9c 100644
--- a/src/shared/secondary/spp_worker_th/cmd_utils.c
+++ b/src/shared/secondary/spp_worker_th/cmd_utils.c
@@ -78,7 +78,7 @@ spp_get_core_status(unsigned int lcore_id)
 /**
  * Check status of all of cores is same as given
  *
- * It returns SPP_RET_NG as status mismatch if status is not same.
+ * It returns SPPWK_RET_NG as status mismatch if status is not same.
  * If core is in use, status will be checked.
  */
 static int
@@ -89,10 +89,10 @@ check_core_status(enum sppwk_lcore_status status)
 		if ((g_mng_data.p_core_info + lcore_id)->status !=
 								status) {
 			/* Status is mismatched */
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 int
@@ -103,11 +103,11 @@ check_core_status_wait(enum sppwk_lcore_status status)
 		sleep(1);
 		int ret = check_core_status(status);
 		if (ret == 0)
-			return SPP_RET_OK;
+			return SPPWK_RET_OK;
 	}
 
 	RTE_LOG(ERR, APP, "Status check time out. (status = %d)\n", status);
-	return SPP_RET_NG;
+	return SPPWK_RET_NG;
 }
 
 /* Set core status */
@@ -444,7 +444,7 @@ init_host_port_info(void)
 		}
 	}
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Setup management info for spp_vf */
@@ -457,9 +457,9 @@ init_mng_data(void)
 	init_component_info();
 
 	int ret = init_host_port_info();
-	if (unlikely(ret != SPP_RET_OK))
-		return SPP_RET_NG;
-	return SPP_RET_OK;
+	if (unlikely(ret != SPPWK_RET_OK))
+		return SPPWK_RET_NG;
+	return SPPWK_RET_OK;
 }
 
 /* Remove sock file if spp is not running */
@@ -514,9 +514,9 @@ spp_check_core_update(unsigned int lcore_id)
 {
 	struct core_mng_info *info = (g_mng_data.p_core_info + lcore_id);
 	if (info->ref_index == info->upd_index)
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 	else
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 }
 
 /* Check if component is using port. */
@@ -534,7 +534,7 @@ spp_check_used_port(
 					g_mng_data.p_component_info;
 
 	if (port == NULL)
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	for (cnt = 0; cnt < RTE_MAX_LCORE; cnt++) {
 		component = (component_info + cnt);
@@ -554,7 +554,7 @@ spp_check_used_port(
 		}
 	}
 
-	return SPP_RET_NG;
+	return SPPWK_RET_NG;
 }
 
 /* Set component update flag for given port */
@@ -589,7 +589,7 @@ get_free_lcore_id(void)
 		if ((comp_info + cnt)->wk_type == SPPWK_TYPE_NONE)
 			return cnt;
 	}
-	return SPP_RET_NG;
+	return SPPWK_RET_NG;
 }
 
 /* Get lcore ID as user-defined component name. */
@@ -600,13 +600,13 @@ sppwk_get_lcore_id(const char *comp_name)
 
 	int cnt = 0;
 	if (comp_name[0] == '\0')
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	for (cnt = 0; cnt < RTE_MAX_LCORE; cnt++) {
 		if (strcmp(comp_name, (comp_info + cnt)->name) == 0)
 			return cnt;
 	}
-	return SPP_RET_NG;
+	return SPPWK_RET_NG;
 }
 
 /**
@@ -618,7 +618,7 @@ get_idx_port_info(struct sppwk_port_info *p_info, int nof_ports,
 		struct sppwk_port_info *p_info_ary[])
 {
 	int cnt = 0;
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	for (cnt = 0; cnt < nof_ports; cnt++) {
 		if (p_info == p_info_ary[cnt])
 			ret = cnt;
@@ -637,7 +637,7 @@ delete_port_info(struct sppwk_port_info *p_info, int nof_ports,
 	/* Find index of target port to be deleted. */
 	target_idx = get_idx_port_info(p_info, nof_ports, p_info_ary);
 	if (target_idx < 0)
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	/**
 	 * Overwrite the deleted port by the next one, and shift all of
@@ -647,7 +647,7 @@ delete_port_info(struct sppwk_port_info *p_info, int nof_ports,
 	for (cnt = target_idx; cnt < nof_ports; cnt++)
 		p_info_ary[cnt] = p_info_ary[cnt+1];
 	p_info_ary[cnt] = NULL;  /* Remove old last port. */
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Activate temporarily stored port info while flushing. */
@@ -665,7 +665,7 @@ update_port_info(void)
 		if ((port->iface_type != UNDEF) && (port->ethdev_port_id < 0)) {
 			ret = add_vhost_pmd(port->iface_no);
 			if (ret < 0)
-				return SPP_RET_NG;
+				return SPPWK_RET_NG;
 			port->ethdev_port_id = ret;
 		}
 	}
@@ -676,11 +676,11 @@ update_port_info(void)
 		if ((port->iface_type != UNDEF) && (port->ethdev_port_id < 0)) {
 			ret = add_ring_pmd(port->iface_no);
 			if (ret < 0)
-				return SPP_RET_NG;
+				return SPPWK_RET_NG;
 			port->ethdev_port_id = ret;
 		}
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Activate temporarily stored lcore info while flushing. */
@@ -730,12 +730,12 @@ int sppwk_port_uid(char *port_uid, enum port_type p_type, int iface_no)
 		p_type_str = SPPWK_VHOST_STR;
 		break;
 	default:
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	sprintf(port_uid, "%s:%d", p_type_str, iface_no);
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Convert MAC address of 'aa:bb:cc:dd:ee:ff' to value of int64_t. */
@@ -764,7 +764,7 @@ sppwk_convert_mac_str_to_int64(const char *macaddr)
 			RTE_LOG(ERR, APP,
 					"Invalid MAC address `%s`.\n",
 					macaddr);
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 
 		/* Convert string to hex value */
@@ -801,7 +801,7 @@ int sppwk_set_mng_data(
 	if (iface_p == NULL || component_p == NULL || core_mng_p == NULL ||
 			change_core_p == NULL || change_component_p == NULL ||
 			backup_info_p == NULL)
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 
 	g_mng_data.p_iface_info = iface_p;
 	g_mng_data.p_component_info = component_p;
@@ -810,7 +810,7 @@ int sppwk_set_mng_data(
 	g_mng_data.p_change_component = change_component_p;
 	g_mng_data.p_backup_info = backup_info_p;
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Get management data from global var for given non-NULL args. */
diff --git a/src/shared/secondary/spp_worker_th/cmd_utils.h b/src/shared/secondary/spp_worker_th/cmd_utils.h
index 2d7c389..6e9695c 100644
--- a/src/shared/secondary/spp_worker_th/cmd_utils.h
+++ b/src/shared/secondary/spp_worker_th/cmd_utils.h
@@ -397,8 +397,8 @@ struct core_info *get_core_info(unsigned int lcore_id);
  * Check core index change
  *
  * @param lcore_id Lcore ID.
- * @retval SPP_RET_OK If index is updated.
- * @retval SPP_RET_NG If index is not updated.
+ * @retval SPPWK_RET_OK If index is updated.
+ * @retval SPPWK_RET_NG If index is not updated.
  */
 int spp_check_core_update(unsigned int lcore_id);
 
@@ -409,7 +409,7 @@ int spp_check_core_update(unsigned int lcore_id);
  * @param iface_no Interface number to be validated.
  * @param rxtx Value of spp_port_rxtx to be validated.
  * @retval 0~127      If match component ID
- * @retval SPP_RET_NG If failed.
+ * @retval SPPWK_RET_NG If failed.
  */
 int spp_check_used_port(
 		enum port_type iface_type,
@@ -439,7 +439,7 @@ int get_free_lcore_id(void);
  *
  * @param[in] name Component name.
  * @retval 0~127 Component ID.
- * @retval SPP_RET_NG if failed.
+ * @retval SPPWK_RET_NG if failed.
  */
 int sppwk_get_lcore_id(const char *comp_name);
 
@@ -471,8 +471,8 @@ int delete_port_info(struct sppwk_port_info *p_info, int nof_ports,
 /**
  * Activate temporarily stored port info while flushing.
  *
- * @retval SPP_RET_OK if succeeded.
- * @retval SPP_RET_NG if failed.
+ * @retval SPPWK_RET_OK if succeeded.
+ * @retval SPPWK_RET_NG if failed.
  */
 int update_port_info(void);
 
@@ -485,7 +485,7 @@ void update_lcore_info(void);
  * @param[in,out] port_uid String of port type to be converted.
  * @param[in] iface_type Interface type such as PHY or so.
  * @param[in] iface_no Interface number.
- * @return SPP_RET_OK If succeeded, or SPP_RET_NG if failed.
+ * @return SPPWK_RET_OK If succeeded, or SPPWK_RET_NG if failed.
  */
 int
 sppwk_port_uid(char *port_uid, enum port_type iface_type, int iface_no);
@@ -495,7 +495,7 @@ sppwk_port_uid(char *port_uid, enum port_type iface_type, int iface_no);
  *
  * @param macaddr String of MAC address to be converted.
  * @retval 0~N MAC address in int64 format.
- * @retval SPP_RET_NG if invalid.
+ * @retval SPPWK_RET_NG if invalid.
  */
 int64_t sppwk_convert_mac_str_to_int64(const char *macaddr);
 
@@ -508,8 +508,8 @@ int64_t sppwk_convert_mac_str_to_int64(const char *macaddr);
  * @param change_core_p Pointer to g_change_core address.
  * @param change_component_p Pointer to g_change_component address.
  * @param backup_info_p Pointer to g_backup_info address.
- * @retval SPP_RET_OK If succeeded.
- * @retval SPP_RET_NG If failed.
+ * @retval SPPWK_RET_OK If succeeded.
+ * @retval SPPWK_RET_NG If failed.
  */
 int sppwk_set_mng_data(struct iface_info *iface_p,
 		struct sppwk_comp_info *component_p,
diff --git a/src/shared/secondary/spp_worker_th/conn_spp_ctl.c b/src/shared/secondary/spp_worker_th/conn_spp_ctl.c
index a67cd10..f162293 100644
--- a/src/shared/secondary/spp_worker_th/conn_spp_ctl.c
+++ b/src/shared/secondary/spp_worker_th/conn_spp_ctl.c
@@ -35,7 +35,7 @@ conn_spp_ctl_init(const char *ctl_ipaddr, int ctl_port)
 	strcpy(g_controller_ip, ctl_ipaddr);
 	g_controller_port = ctl_port;
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* connect to controller */
@@ -43,11 +43,11 @@ int
 conn_spp_ctl(int *sock)
 {
 	static struct sockaddr_in controller_addr;
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	int sock_flg = 0;
 
 	if (likely(*sock >= 0))
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 
 	/* create socket */
 	RTE_LOG(INFO, SPP_COMMAND_PROC, "Creating socket...\n");
@@ -86,14 +86,14 @@ conn_spp_ctl(int *sock)
 	sock_flg = fcntl(*sock, F_GETFL, 0);
 	fcntl(*sock, F_SETFL, sock_flg | O_NONBLOCK);
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* receive message */
 int
 recv_ctl_msg(int *sock, char **strbuf)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 	int n_rx = 0;
 	char *new_strbuf = NULL;
 
@@ -110,7 +110,7 @@ recv_ctl_msg(int *sock, char **strbuf)
 					"Receive failure. errno=%d\n", errno);
 		} else {
 			/* no receive message */
-			return SPP_RET_OK;
+			return SPPWK_RET_OK;
 		}
 
 		RTE_LOG(INFO, SPP_COMMAND_PROC, "Assume Server closed "
@@ -139,7 +139,7 @@ recv_ctl_msg(int *sock, char **strbuf)
 int
 send_ctl_msg(int *sock, const char *msg, size_t msg_len)
 {
-	int ret = SPP_RET_NG;
+	int ret = SPPWK_RET_NG;
 
 	ret = send(*sock, msg, msg_len, 0);
 	if (unlikely(ret == -1)) {
@@ -149,5 +149,5 @@ send_ctl_msg(int *sock, const char *msg, size_t msg_len)
 		return SPP_CONNERR_TEMPORARY;
 	}
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
diff --git a/src/shared/secondary/spp_worker_th/conn_spp_ctl.h b/src/shared/secondary/spp_worker_th/conn_spp_ctl.h
index 0d06131..c1f197c 100644
--- a/src/shared/secondary/spp_worker_th/conn_spp_ctl.h
+++ b/src/shared/secondary/spp_worker_th/conn_spp_ctl.h
@@ -23,8 +23,8 @@
  *
  * @param[in] ctl_ipaddr IP address of spp-ctl.
  * @param[in] ctl_port Port num of spp-ctl.
- * @retval SPP_RET_OK If succeeded.
- * @retval SPP_RET_NG If failed.
+ * @retval SPPWK_RET_OK If succeeded.
+ * @retval SPPWK_RET_NG If failed.
  */
 int conn_spp_ctl_init(const char *ctl_ipaddr, int ctl_port);
 
@@ -33,7 +33,7 @@ int conn_spp_ctl_init(const char *ctl_ipaddr, int ctl_port);
  *
  * @note bocking.
  * @param sock Socket number for connecting to controller.
- * @retval SPP_RET_OK If succeeded.
+ * @retval SPPWK_RET_OK If succeeded.
  * @retval SPP_CONNERR_TEMPORARY Temporary error for retry.
  */
 int conn_spp_ctl(int *sock);
@@ -41,7 +41,7 @@ int conn_spp_ctl(int *sock);
 /**
  * Receive message from spp-ctl.
  *
- * This function returns the num of received  msg in bytes, or SPP_RET_OK
+ * This function returns the num of received  msg in bytes, or SPPWK_RET_OK
  * if empty message. Given socket is closed if spp-ctl has terminated the
  * session.
  *
@@ -49,7 +49,7 @@ int conn_spp_ctl(int *sock);
  * @param[in,out] sock Socket.
  * @param[in,out] msgbuf The pointer to command message buffer.
  * @retval NOB_BYTES Num of bytes of received msg if succeeded.
- * @retval SPP_RET_OK No receive message.
+ * @retval SPPWK_RET_OK No receive message.
  * @retval SPP_CONNERR_TEMPORARY Temporary error for retry.
  * @retval SPP_CONNERR_FATAL Fatal error for terminating the process.
  */
@@ -62,7 +62,7 @@ int recv_ctl_msg(int *sock, char **msgbuf);
  * @param[in,out] sock Socket.
  * @param[in] msg Message sent to spp-ctl.
  * @param[in] msg_len Length of given message.
- * @retval SPP_RET_OK If succeeded.
+ * @retval SPPWK_RET_OK If succeeded.
  * @retval SPP_CONNERR_TEMPORARY Temporary error for retry.
  */
 int send_ctl_msg(int *sock, const char *msg, size_t msg_len);
diff --git a/src/shared/secondary/spp_worker_th/mirror_deps.h b/src/shared/secondary/spp_worker_th/mirror_deps.h
index 085b01e..7182bf1 100644
--- a/src/shared/secondary/spp_worker_th/mirror_deps.h
+++ b/src/shared/secondary/spp_worker_th/mirror_deps.h
@@ -23,8 +23,8 @@ int add_core(const char *name, char **output,
  * Update mirror info.
  *
  * @param wk_comp_info Pointer to internal data of mirror.
- * @retval SPP_RET_OK If succeeded.
- * @retval SPP_RET_NG If failed.
+ * @retval SPPWK_RET_OK If succeeded.
+ * @retval SPPWK_RET_NG If failed.
  */
 int update_mirror(struct sppwk_comp_info *wk_comp_info);
 
@@ -33,8 +33,8 @@ int update_mirror(struct sppwk_comp_info *wk_comp_info);
  *
  * @param[in] p_comp_info Info of component.
  * @param[in] p_change_comp Pointer to a set of Flags for udpated component.
- * @retval SPP_RET_OK If succeeded.
- * @retval SPP_RET_NG If failed.
+ * @retval SPPWK_RET_OK If succeeded.
+ * @retval SPPWK_RET_NG If failed.
  */
 int update_comp_info(struct sppwk_comp_info *p_comp_info, int *p_change_comp);
 
diff --git a/src/shared/secondary/spp_worker_th/port_capability.c b/src/shared/secondary/spp_worker_th/port_capability.c
index 917d5fc..43dda54 100644
--- a/src/shared/secondary/spp_worker_th/port_capability.c
+++ b/src/shared/secondary/spp_worker_th/port_capability.c
@@ -122,7 +122,7 @@ add_vlan_tag_one(
 		if (unlikely(new_ether == NULL)) {
 			RTE_LOG(ERR, PORT, "Failed to "
 					"get additional header area.\n");
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 
 		rte_memcpy(new_ether, old_ether, sizeof(struct ether_hdr));
@@ -133,7 +133,7 @@ add_vlan_tag_one(
 
 	vlan->vlan_tci = vlantag->tci;
 	set_fcs_packet(pkt);
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Add VLAN tag to all packets. */
@@ -142,7 +142,7 @@ add_vlan_tag_all(
 		struct rte_mbuf **pkts, int nb_pkts,
 		const union sppwk_port_capability *capability)
 {
-	int ret = SPP_RET_OK;
+	int ret = SPPWK_RET_OK;
 	int cnt = 0;
 	for (cnt = 0; cnt < nb_pkts; cnt++) {
 		ret = add_vlan_tag_one(pkts[cnt], capability);
@@ -174,7 +174,7 @@ del_vlan_tag_one(
 		if (unlikely(new_ether == NULL)) {
 			RTE_LOG(ERR, PORT, "Failed to "
 					"delete unnecessary header area.\n");
-			return SPP_RET_NG;
+			return SPPWK_RET_NG;
 		}
 
 		old = (uint32_t *)old_ether;
@@ -185,7 +185,7 @@ del_vlan_tag_one(
 		old[0] = 0;
 		set_fcs_packet(pkt);
 	}
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 /* Delete VLAN tag from all packets. */
@@ -194,7 +194,7 @@ del_vlan_tag_all(
 		struct rte_mbuf **pkts, int nb_pkts,
 		const union sppwk_port_capability *capability)
 {
-	int ret = SPP_RET_OK;
+	int ret = SPPWK_RET_OK;
 	int cnt = 0;
 	for (cnt = 0; cnt < nb_pkts; cnt++) {
 		ret = del_vlan_tag_one(pkts[cnt], capability);
@@ -384,7 +384,7 @@ sppwk_eth_vlan_rx_burst(uint16_t port_id,
 	uint16_t nb_rx;
 	nb_rx = rte_eth_rx_burst(port_id, 0, rx_pkts, nb_pkts);
 	if (unlikely(nb_rx == 0))
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 
 	/* Add or delete VLAN tag. */
 	return vlan_operation(port_id, rx_pkts, nb_rx, SPPWK_PORT_DIR_RX);
@@ -402,7 +402,7 @@ sppwk_eth_vlan_tx_burst(uint16_t port_id,
 	nb_tx = vlan_operation(port_id, tx_pkts, nb_pkts, SPPWK_PORT_DIR_TX);
 
 	if (unlikely(nb_tx == 0))
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 
 	return rte_eth_tx_burst(port_id, 0, tx_pkts, nb_tx);
 }
@@ -419,7 +419,7 @@ sppwk_eth_vlan_ring_stats_rx_burst(uint16_t port_id,
 	uint16_t nb_rx;
 	nb_rx = rte_eth_rx_burst(port_id, 0, rx_pkts, nb_pkts);
 	if (unlikely(nb_rx == 0))
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 
 	if (iface_type == RING)
 		spp_ringlatencystats_calculate_latency(iface_no,
@@ -442,7 +442,7 @@ sppwk_eth_vlan_ring_stats_tx_burst(uint16_t port_id,
 	nb_tx = vlan_operation(port_id, tx_pkts, nb_pkts, SPPWK_PORT_DIR_TX);
 
 	if (unlikely(nb_tx == 0))
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 
 	if (iface_type == RING) {
 		spp_ringlatencystats_add_time_stamp(iface_no, tx_pkts, nb_pkts);
diff --git a/src/shared/secondary/spp_worker_th/ringlatencystats.c b/src/shared/secondary/spp_worker_th/ringlatencystats.c
index 5678e37..b0f2080 100644
--- a/src/shared/secondary/spp_worker_th/ringlatencystats.c
+++ b/src/shared/secondary/spp_worker_th/ringlatencystats.c
@@ -60,7 +60,7 @@ spp_ringlatencystats_init(uint64_t samp_intvl, uint16_t stats_count)
 	if (unlikely(g_stats_info == NULL)) {
 		RTE_LOG(ERR, SPP_RING_LATENCY_STATS, "Cannot allocate memory "
 				"for ring latency stats info\n");
-		return SPP_RET_NG;
+		return SPPWK_RET_NG;
 	}
 
 	/* store global information for ring latency statistics */
@@ -73,7 +73,7 @@ spp_ringlatencystats_init(uint64_t samp_intvl, uint16_t stats_count)
 			g_samp_intvl, g_stats_count,
 			cycles_per_ns(), NS_PER_SEC);
 
-	return SPP_RET_OK;
+	return SPPWK_RET_OK;
 }
 
 void
@@ -211,9 +211,9 @@ sppwk_eth_ring_stats_rx_burst(uint16_t port_id,
 
 	nb_rx = rte_eth_rx_burst(port_id, 0, rx_pkts, nb_pkts);
 
-	/* TODO(yasufum) confirm why it returns SPP_RET_OK. */
+	/* TODO(yasufum) confirm why it returns SPPWK_RET_OK. */
 	if (unlikely(nb_rx == 0))
-		return SPP_RET_OK;
+		return SPPWK_RET_OK;
 
 	if (iface_type == RING)
 		spp_ringlatencystats_calculate_latency(
diff --git a/src/shared/secondary/spp_worker_th/ringlatencystats.h b/src/shared/secondary/spp_worker_th/ringlatencystats.h
index 33c456d..332b4b8 100644
--- a/src/shared/secondary/spp_worker_th/ringlatencystats.h
+++ b/src/shared/secondary/spp_worker_th/ringlatencystats.h
@@ -34,8 +34,8 @@ struct spp_ringlatencystats_ring_latency_stats {
  * @param stats_count
  *  The number of ring to be measured.
  *
- * @retval SPP_RET_OK: succeeded.
- * @retval SPP_RET_NG: failed.
+ * @retval SPPWK_RET_OK: succeeded.
+ * @retval SPPWK_RET_NG: failed.
  */
 int spp_ringlatencystats_init(uint64_t samp_intvl, uint16_t stats_count);
 
diff --git a/src/shared/secondary/spp_worker_th/vf_deps.h b/src/shared/secondary/spp_worker_th/vf_deps.h
index 83ddf09..35ac201 100644
--- a/src/shared/secondary/spp_worker_th/vf_deps.h
+++ b/src/shared/secondary/spp_worker_th/vf_deps.h
@@ -69,8 +69,8 @@ int exec_one_cmd(const struct sppwk_cmd_attrs *cmd);
  * Update classifier info.
  *
  * @param wk_comp_info Pointer to internal data of classifier.
- * @retval SPP_RET_OK If succeeded.
- * @retval SPP_RET_NG If failed.
+ * @retval SPPWK_RET_OK If succeeded.
+ * @retval SPPWK_RET_NG If failed.
  */
 int update_classifier(struct sppwk_comp_info *wk_comp_info);
 
@@ -78,8 +78,8 @@ int update_classifier(struct sppwk_comp_info *wk_comp_info);
  * Update forwarder info.
  *
  * @param component Pointer to data of forwarder and merger.
- * @retval SPP_RET_OK If succeeded.
- * @retval SPP_RET_NG If failed.
+ * @retval SPPWK_RET_OK If succeeded.
+ * @retval SPPWK_RET_NG If failed.
  */
 int update_forwarder(struct sppwk_comp_info *wk_comp_info);
 
@@ -101,8 +101,8 @@ int add_classifier_table_val(
  *
  * @param[in] p_comp_info Info of component.
  * @param[in] p_change_comp Pointer to a set of Flags for udpated component.
- * @retval SPP_RET_OK If succeeded.
- * @retval SPP_RET_NG If failed.
+ * @retval SPPWK_RET_OK If succeeded.
+ * @retval SPPWK_RET_NG If failed.
  */
 int update_comp_info(struct sppwk_comp_info *p_comp_info, int *p_change_comp);
 
-- 
2.17.1

